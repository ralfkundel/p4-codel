#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from pd_fixed.ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def tm_allocate_ppg(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_free_ppg(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    pass

  def tm_get_default_ppg(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_set_ppg_icos_mapping(self, dev, ppg, icos_map):
    """
    Parameters:
     - dev
     - ppg
     - icos_map
    """
    pass

  def tm_enable_lossless_treatment(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    pass

  def tm_disable_lossless_treatment(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    pass

  def tm_set_ppg_app_pool_usage(self, dev, ppg, pool, base_use_limit, dynamic_baf, hysteresis):
    """
    Parameters:
     - dev
     - ppg
     - pool
     - base_use_limit
     - dynamic_baf
     - hysteresis
    """
    pass

  def tm_disable_ppg_app_pool_usage(self, dev, pool, ppg):
    """
    Parameters:
     - dev
     - pool
     - ppg
    """
    pass

  def tm_set_ppg_guaranteed_min_limit(self, dev, ppg, cells):
    """
    Parameters:
     - dev
     - ppg
     - cells
    """
    pass

  def tm_set_ppg_skid_limit(self, dev, ppg, cells):
    """
    Parameters:
     - dev
     - ppg
     - cells
    """
    pass

  def tm_set_guaranteed_min_skid_hysteresis(self, dev, ppg, cells):
    """
    Parameters:
     - dev
     - ppg
     - cells
    """
    pass

  def tm_set_port_q_mapping(self, dev, port, q_count, q_map):
    """
    Parameters:
     - dev
     - port
     - q_count
     - q_map
    """
    pass

  def tm_set_q_app_pool_usage(self, dev, port, q, pool, base_use_limit, dynamic_baf, hysteresis):
    """
    Parameters:
     - dev
     - port
     - q
     - pool
     - base_use_limit
     - dynamic_baf
     - hysteresis
    """
    pass

  def tm_disable_q_app_pool_usage(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_set_q_guaranteed_min_limit(self, dev, port, q, cells):
    """
    Parameters:
     - dev
     - port
     - q
     - cells
    """
    pass

  def tm_set_q_color_limit(self, dev, port, q, color, cells):
    """
    Parameters:
     - dev
     - port
     - q
     - color
     - cells
    """
    pass

  def tm_set_q_color_hysteresis(self, dev, port, q, color, cells):
    """
    Parameters:
     - dev
     - port
     - q
     - color
     - cells
    """
    pass

  def tm_enable_q_tail_drop(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_disable_q_tail_drop(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_enable_q_color_drop(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_disable_q_color_drop(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_set_negative_mirror_dest(self, dev, pipe, port, q):
    """
    Parameters:
     - dev
     - pipe
     - port
     - q
    """
    pass

  def tm_set_q_pfc_cos_mapping(self, dev, port, q, cos):
    """
    Parameters:
     - dev
     - port
     - q
     - cos
    """
    pass

  def tm_set_app_pool_size(self, dev, pool, cells):
    """
    Parameters:
     - dev
     - pool
     - cells
    """
    pass

  def tm_enable_app_pool_color_drop(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    pass

  def tm_disable_app_pool_color_drop(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    pass

  def tm_set_app_pool_color_drop_limit(self, dev, pool, color, cells):
    """
    Parameters:
     - dev
     - pool
     - color
     - cells
    """
    pass

  def tm_set_app_pool_color_drop_hysteresis(self, dev, color, cells):
    """
    Parameters:
     - dev
     - color
     - cells
    """
    pass

  def tm_set_app_pool_pfc_limit(self, dev, pool, icos, cells):
    """
    Parameters:
     - dev
     - pool
     - icos
     - cells
    """
    pass

  def tm_set_skid_pool_size(self, dev, cells):
    """
    Parameters:
     - dev
     - cells
    """
    pass

  def tm_set_skid_pool_hysteresis(self, dev, cells):
    """
    Parameters:
     - dev
     - cells
    """
    pass

  def tm_set_negative_mirror_pool_size(self, dev, cells):
    """
    Parameters:
     - dev
     - cells
    """
    pass

  def tm_set_uc_cut_through_pool_size(self, dev, cells):
    """
    Parameters:
     - dev
     - cells
    """
    pass

  def tm_set_mc_cut_through_pool_size(self, dev, cells):
    """
    Parameters:
     - dev
     - cells
    """
    pass

  def tm_set_egress_pipe_limit(self, dev, pipe, cells):
    """
    Parameters:
     - dev
     - pipe
     - cells
    """
    pass

  def tm_set_egress_pipe_hysteresis(self, dev, pipe, cells):
    """
    Parameters:
     - dev
     - pipe
     - cells
    """
    pass

  def tm_set_ingress_port_drop_limit(self, dev, port, cells):
    """
    Parameters:
     - dev
     - port
     - cells
    """
    pass

  def tm_set_ingress_port_hysteresis(self, dev, port, cells):
    """
    Parameters:
     - dev
     - port
     - cells
    """
    pass

  def tm_set_port_uc_cut_through_limit(self, dev, port, cells):
    """
    Parameters:
     - dev
     - port
     - cells
    """
    pass

  def tm_set_port_flowcontrol_mode(self, dev, port, fctype):
    """
    Parameters:
     - dev
     - port
     - fctype
    """
    pass

  def tm_set_port_pfc_cos_mapping(self, dev, port, cos_icos_map):
    """
    Parameters:
     - dev
     - port
     - cos_icos_map
    """
    pass

  def tm_set_cpuport(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_reset_cpuport(self, dev):
    """
    Parameters:
     - dev
    """
    pass

  def tm_set_q_sched_priority(self, dev, port, q, prio):
    """
    Parameters:
     - dev
     - port
     - q
     - prio
    """
    pass

  def tm_set_q_dwrr_weight(self, dev, port, q, weight):
    """
    Parameters:
     - dev
     - port
     - q
     - weight
    """
    pass

  def tm_set_q_shaping_rate(self, dev, port, q, pps, burstsize, rate):
    """
    Parameters:
     - dev
     - port
     - q
     - pps
     - burstsize
     - rate
    """
    pass

  def tm_set_q_guaranteed_rate(self, dev, port, q, pps, burstsize, rate):
    """
    Parameters:
     - dev
     - port
     - q
     - pps
     - burstsize
     - rate
    """
    pass

  def tm_set_q_remaining_bw_sched_priority(self, dev, port, q, prio):
    """
    Parameters:
     - dev
     - port
     - q
     - prio
    """
    pass

  def tm_sched_q_l1_set(self, dev, port, l1_node, q):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - q
    """
    pass

  def tm_sched_q_l1_reset(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_sched_l1_priority_set(self, dev, port, l1_node, priority):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - priority
    """
    pass

  def tm_sched_l1_dwrr_weight_set(self, dev, port, l1_node, weight):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - weight
    """
    pass

  def tm_sched_l1_shaping_rate_set(self, dev, port, l1_node, pps, burst_size, rate):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - pps
     - burst_size
     - rate
    """
    pass

  def tm_sched_l1_max_shaping_rate_enable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    pass

  def tm_sched_l1_max_shaping_rate_disable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    pass

  def tm_sched_l1_priority_prop_enable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    pass

  def tm_sched_l1_priority_prop_disable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    pass

  def tm_sched_l1_guaranteed_rate_set(self, dev, port, l1_node, pps, burst_size, rate):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - pps
     - burst_size
     - rate
    """
    pass

  def tm_sched_l1_remaining_bw_priority_set(self, dev, port, l1_node, priority):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - priority
    """
    pass

  def tm_sched_l1_guaranteed_rate_enable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    pass

  def tm_sched_l1_guaranteed_rate_disable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    pass

  def tm_sched_l1_enable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    pass

  def tm_sched_l1_disable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    pass

  def tm_sched_l1_free(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    pass

  def tm_set_port_shaping_rate(self, dev, port, pps, burstsize, rate):
    """
    Parameters:
     - dev
     - port
     - pps
     - burstsize
     - rate
    """
    pass

  def tm_set_shaper_pkt_ifg_compensation(self, dev, pipe, adjustment):
    """
    Parameters:
     - dev
     - pipe
     - adjustment
    """
    pass

  def tm_enable_q_sched(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_disable_q_sched(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_enable_port_shaping(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_disable_port_shaping(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_enable_port_sched(self, dev, port, speed):
    """
    Parameters:
     - dev
     - port
     - speed
    """
    pass

  def tm_disable_port_sched(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_enable_q_max_shaping_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_disable_q_max_shaping_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_enable_q_min_shaping_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_disable_q_min_shaping_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_complete_operations(self, dev):
    """
    Parameters:
     - dev
    """
    pass

  def tm_set_timestamp_shift(self, dev, shift):
    """
    Parameters:
     - dev
     - shift
    """
    pass

  def tm_get_q_sched_priority(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_get_q_dwrr_weight(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_get_q_shaping_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_get_q_guaranteed_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_get_q_remaining_bw_sched_priority(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_get_port_shaping_rate(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_get_shaper_pkt_ifg_compensation(self, dev, pipe):
    """
    Parameters:
     - dev
     - pipe
    """
    pass

  def tm_get_egress_pipe_limit(self, dev, pipe):
    """
    Parameters:
     - dev
     - pipe
    """
    pass

  def tm_get_egress_pipe_hysteresis(self, dev, pipe):
    """
    Parameters:
     - dev
     - pipe
    """
    pass

  def tm_get_port_q_mapping(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_get_q_app_pool_usage(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_get_q_guaranteed_min_limit(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    pass

  def tm_get_q_color_limit(self, dev, port, q, color):
    """
    Parameters:
     - dev
     - port
     - q
     - color
    """
    pass

  def tm_get_q_color_hysteresis(self, dev, port, q, color):
    """
    Parameters:
     - dev
     - port
     - q
     - color
    """
    pass

  def tm_get_port_uc_cut_through_limit(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_get_total_ppg(self, dev, pipe):
    """
    Parameters:
     - dev
     - pipe
    """
    pass

  def tm_get_unused_ppg_count(self, dev, pipe):
    """
    Parameters:
     - dev
     - pipe
    """
    pass

  def tm_get_ppg_app_pool_usage(self, dev, ppg, pool):
    """
    Parameters:
     - dev
     - ppg
     - pool
    """
    pass

  def tm_get_ppg_guaranteed_min_limit(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    pass

  def tm_get_ppg_skid_limit(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    pass

  def tm_get_ppg_guaranteed_min_skid_hysteresis(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    pass

  def tm_get_app_pool_size(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    pass

  def tm_get_app_pool_color_drop_limit(self, dev, pool, color):
    """
    Parameters:
     - dev
     - pool
     - color
    """
    pass

  def tm_get_app_pool_color_drop_hysteresis(self, dev, color):
    """
    Parameters:
     - dev
     - color
    """
    pass

  def tm_get_app_pool_pfc_limit(self, dev, pool, icos):
    """
    Parameters:
     - dev
     - pool
     - icos
    """
    pass

  def tm_get_skid_pool_size(self, dev):
    """
    Parameters:
     - dev
    """
    pass

  def tm_get_skid_pool_hysteresis(self, dev):
    """
    Parameters:
     - dev
    """
    pass

  def tm_get_negative_mirror_pool_size(self, dev):
    """
    Parameters:
     - dev
    """
    pass

  def tm_get_uc_cut_through_pool_size(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    pass

  def tm_get_mc_cut_through_pool_size(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    pass

  def tm_get_ingress_port_drop_limit(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_get_ingress_port_hysteresis(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_get_port_flowcontrol_mode(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_get_port_pfc_cos_mapping(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    pass

  def tm_get_ppg_icos_mapping(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    pass

  def tm_get_timestamp_shift(self, dev):
    """
    Parameters:
     - dev
    """
    pass

  def tm_get_ppg_drop(self, dev, pipe, ppg):
    """
    Parameters:
     - dev
     - pipe
     - ppg
    """
    pass

  def tm_get_q_drop(self, dev, pipe, port, q):
    """
    Parameters:
     - dev
     - pipe
     - port
     - q
    """
    pass

  def tm_get_ppg_usage(self, dev, pipe, ppg):
    """
    Parameters:
     - dev
     - pipe
     - ppg
    """
    pass

  def tm_get_q_usage(self, dev, pipe, port, q):
    """
    Parameters:
     - dev
     - pipe
     - port
     - q
    """
    pass

  def tm_get_pool_usage(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    pass

  def tm_set_ut_mode_as_model(self, dev):
    """
    Parameters:
     - dev
    """
    pass

  def tm_set_ut_mode_as_asic(self, dev):
    """
    Parameters:
     - dev
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def tm_allocate_ppg(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_allocate_ppg(dev, port)
    return self.recv_tm_allocate_ppg()

  def send_tm_allocate_ppg(self, dev, port):
    self._oprot.writeMessageBegin('tm_allocate_ppg', TMessageType.CALL, self._seqid)
    args = tm_allocate_ppg_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_allocate_ppg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_allocate_ppg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_allocate_ppg failed: unknown result");

  def tm_free_ppg(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    self.send_tm_free_ppg(dev, ppg)
    self.recv_tm_free_ppg()

  def send_tm_free_ppg(self, dev, ppg):
    self._oprot.writeMessageBegin('tm_free_ppg', TMessageType.CALL, self._seqid)
    args = tm_free_ppg_args()
    args.dev = dev
    args.ppg = ppg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_free_ppg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_free_ppg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_get_default_ppg(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_get_default_ppg(dev, port)
    return self.recv_tm_get_default_ppg()

  def send_tm_get_default_ppg(self, dev, port):
    self._oprot.writeMessageBegin('tm_get_default_ppg', TMessageType.CALL, self._seqid)
    args = tm_get_default_ppg_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_default_ppg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_default_ppg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_default_ppg failed: unknown result");

  def tm_set_ppg_icos_mapping(self, dev, ppg, icos_map):
    """
    Parameters:
     - dev
     - ppg
     - icos_map
    """
    self.send_tm_set_ppg_icos_mapping(dev, ppg, icos_map)
    self.recv_tm_set_ppg_icos_mapping()

  def send_tm_set_ppg_icos_mapping(self, dev, ppg, icos_map):
    self._oprot.writeMessageBegin('tm_set_ppg_icos_mapping', TMessageType.CALL, self._seqid)
    args = tm_set_ppg_icos_mapping_args()
    args.dev = dev
    args.ppg = ppg
    args.icos_map = icos_map
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_ppg_icos_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_ppg_icos_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_enable_lossless_treatment(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    self.send_tm_enable_lossless_treatment(dev, ppg)
    self.recv_tm_enable_lossless_treatment()

  def send_tm_enable_lossless_treatment(self, dev, ppg):
    self._oprot.writeMessageBegin('tm_enable_lossless_treatment', TMessageType.CALL, self._seqid)
    args = tm_enable_lossless_treatment_args()
    args.dev = dev
    args.ppg = ppg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_enable_lossless_treatment(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_enable_lossless_treatment_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_lossless_treatment(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    self.send_tm_disable_lossless_treatment(dev, ppg)
    self.recv_tm_disable_lossless_treatment()

  def send_tm_disable_lossless_treatment(self, dev, ppg):
    self._oprot.writeMessageBegin('tm_disable_lossless_treatment', TMessageType.CALL, self._seqid)
    args = tm_disable_lossless_treatment_args()
    args.dev = dev
    args.ppg = ppg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_lossless_treatment(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_lossless_treatment_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_ppg_app_pool_usage(self, dev, ppg, pool, base_use_limit, dynamic_baf, hysteresis):
    """
    Parameters:
     - dev
     - ppg
     - pool
     - base_use_limit
     - dynamic_baf
     - hysteresis
    """
    self.send_tm_set_ppg_app_pool_usage(dev, ppg, pool, base_use_limit, dynamic_baf, hysteresis)
    self.recv_tm_set_ppg_app_pool_usage()

  def send_tm_set_ppg_app_pool_usage(self, dev, ppg, pool, base_use_limit, dynamic_baf, hysteresis):
    self._oprot.writeMessageBegin('tm_set_ppg_app_pool_usage', TMessageType.CALL, self._seqid)
    args = tm_set_ppg_app_pool_usage_args()
    args.dev = dev
    args.ppg = ppg
    args.pool = pool
    args.base_use_limit = base_use_limit
    args.dynamic_baf = dynamic_baf
    args.hysteresis = hysteresis
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_ppg_app_pool_usage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_ppg_app_pool_usage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_ppg_app_pool_usage(self, dev, pool, ppg):
    """
    Parameters:
     - dev
     - pool
     - ppg
    """
    self.send_tm_disable_ppg_app_pool_usage(dev, pool, ppg)
    self.recv_tm_disable_ppg_app_pool_usage()

  def send_tm_disable_ppg_app_pool_usage(self, dev, pool, ppg):
    self._oprot.writeMessageBegin('tm_disable_ppg_app_pool_usage', TMessageType.CALL, self._seqid)
    args = tm_disable_ppg_app_pool_usage_args()
    args.dev = dev
    args.pool = pool
    args.ppg = ppg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_ppg_app_pool_usage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_ppg_app_pool_usage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_ppg_guaranteed_min_limit(self, dev, ppg, cells):
    """
    Parameters:
     - dev
     - ppg
     - cells
    """
    self.send_tm_set_ppg_guaranteed_min_limit(dev, ppg, cells)
    self.recv_tm_set_ppg_guaranteed_min_limit()

  def send_tm_set_ppg_guaranteed_min_limit(self, dev, ppg, cells):
    self._oprot.writeMessageBegin('tm_set_ppg_guaranteed_min_limit', TMessageType.CALL, self._seqid)
    args = tm_set_ppg_guaranteed_min_limit_args()
    args.dev = dev
    args.ppg = ppg
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_ppg_guaranteed_min_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_ppg_guaranteed_min_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_ppg_skid_limit(self, dev, ppg, cells):
    """
    Parameters:
     - dev
     - ppg
     - cells
    """
    self.send_tm_set_ppg_skid_limit(dev, ppg, cells)
    self.recv_tm_set_ppg_skid_limit()

  def send_tm_set_ppg_skid_limit(self, dev, ppg, cells):
    self._oprot.writeMessageBegin('tm_set_ppg_skid_limit', TMessageType.CALL, self._seqid)
    args = tm_set_ppg_skid_limit_args()
    args.dev = dev
    args.ppg = ppg
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_ppg_skid_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_ppg_skid_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_guaranteed_min_skid_hysteresis(self, dev, ppg, cells):
    """
    Parameters:
     - dev
     - ppg
     - cells
    """
    self.send_tm_set_guaranteed_min_skid_hysteresis(dev, ppg, cells)
    self.recv_tm_set_guaranteed_min_skid_hysteresis()

  def send_tm_set_guaranteed_min_skid_hysteresis(self, dev, ppg, cells):
    self._oprot.writeMessageBegin('tm_set_guaranteed_min_skid_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_set_guaranteed_min_skid_hysteresis_args()
    args.dev = dev
    args.ppg = ppg
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_guaranteed_min_skid_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_guaranteed_min_skid_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_port_q_mapping(self, dev, port, q_count, q_map):
    """
    Parameters:
     - dev
     - port
     - q_count
     - q_map
    """
    self.send_tm_set_port_q_mapping(dev, port, q_count, q_map)
    self.recv_tm_set_port_q_mapping()

  def send_tm_set_port_q_mapping(self, dev, port, q_count, q_map):
    self._oprot.writeMessageBegin('tm_set_port_q_mapping', TMessageType.CALL, self._seqid)
    args = tm_set_port_q_mapping_args()
    args.dev = dev
    args.port = port
    args.q_count = q_count
    args.q_map = q_map
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_port_q_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_port_q_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_q_app_pool_usage(self, dev, port, q, pool, base_use_limit, dynamic_baf, hysteresis):
    """
    Parameters:
     - dev
     - port
     - q
     - pool
     - base_use_limit
     - dynamic_baf
     - hysteresis
    """
    self.send_tm_set_q_app_pool_usage(dev, port, q, pool, base_use_limit, dynamic_baf, hysteresis)
    self.recv_tm_set_q_app_pool_usage()

  def send_tm_set_q_app_pool_usage(self, dev, port, q, pool, base_use_limit, dynamic_baf, hysteresis):
    self._oprot.writeMessageBegin('tm_set_q_app_pool_usage', TMessageType.CALL, self._seqid)
    args = tm_set_q_app_pool_usage_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.pool = pool
    args.base_use_limit = base_use_limit
    args.dynamic_baf = dynamic_baf
    args.hysteresis = hysteresis
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_q_app_pool_usage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_q_app_pool_usage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_q_app_pool_usage(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_disable_q_app_pool_usage(dev, port, q)
    self.recv_tm_disable_q_app_pool_usage()

  def send_tm_disable_q_app_pool_usage(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_disable_q_app_pool_usage', TMessageType.CALL, self._seqid)
    args = tm_disable_q_app_pool_usage_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_q_app_pool_usage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_q_app_pool_usage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_q_guaranteed_min_limit(self, dev, port, q, cells):
    """
    Parameters:
     - dev
     - port
     - q
     - cells
    """
    self.send_tm_set_q_guaranteed_min_limit(dev, port, q, cells)
    self.recv_tm_set_q_guaranteed_min_limit()

  def send_tm_set_q_guaranteed_min_limit(self, dev, port, q, cells):
    self._oprot.writeMessageBegin('tm_set_q_guaranteed_min_limit', TMessageType.CALL, self._seqid)
    args = tm_set_q_guaranteed_min_limit_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_q_guaranteed_min_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_q_guaranteed_min_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_q_color_limit(self, dev, port, q, color, cells):
    """
    Parameters:
     - dev
     - port
     - q
     - color
     - cells
    """
    self.send_tm_set_q_color_limit(dev, port, q, color, cells)
    self.recv_tm_set_q_color_limit()

  def send_tm_set_q_color_limit(self, dev, port, q, color, cells):
    self._oprot.writeMessageBegin('tm_set_q_color_limit', TMessageType.CALL, self._seqid)
    args = tm_set_q_color_limit_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.color = color
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_q_color_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_q_color_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_q_color_hysteresis(self, dev, port, q, color, cells):
    """
    Parameters:
     - dev
     - port
     - q
     - color
     - cells
    """
    self.send_tm_set_q_color_hysteresis(dev, port, q, color, cells)
    self.recv_tm_set_q_color_hysteresis()

  def send_tm_set_q_color_hysteresis(self, dev, port, q, color, cells):
    self._oprot.writeMessageBegin('tm_set_q_color_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_set_q_color_hysteresis_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.color = color
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_q_color_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_q_color_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_enable_q_tail_drop(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_enable_q_tail_drop(dev, port, q)
    self.recv_tm_enable_q_tail_drop()

  def send_tm_enable_q_tail_drop(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_enable_q_tail_drop', TMessageType.CALL, self._seqid)
    args = tm_enable_q_tail_drop_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_enable_q_tail_drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_enable_q_tail_drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_q_tail_drop(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_disable_q_tail_drop(dev, port, q)
    self.recv_tm_disable_q_tail_drop()

  def send_tm_disable_q_tail_drop(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_disable_q_tail_drop', TMessageType.CALL, self._seqid)
    args = tm_disable_q_tail_drop_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_q_tail_drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_q_tail_drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_enable_q_color_drop(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_enable_q_color_drop(dev, port, q)
    self.recv_tm_enable_q_color_drop()

  def send_tm_enable_q_color_drop(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_enable_q_color_drop', TMessageType.CALL, self._seqid)
    args = tm_enable_q_color_drop_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_enable_q_color_drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_enable_q_color_drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_q_color_drop(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_disable_q_color_drop(dev, port, q)
    self.recv_tm_disable_q_color_drop()

  def send_tm_disable_q_color_drop(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_disable_q_color_drop', TMessageType.CALL, self._seqid)
    args = tm_disable_q_color_drop_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_q_color_drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_q_color_drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_negative_mirror_dest(self, dev, pipe, port, q):
    """
    Parameters:
     - dev
     - pipe
     - port
     - q
    """
    self.send_tm_set_negative_mirror_dest(dev, pipe, port, q)
    self.recv_tm_set_negative_mirror_dest()

  def send_tm_set_negative_mirror_dest(self, dev, pipe, port, q):
    self._oprot.writeMessageBegin('tm_set_negative_mirror_dest', TMessageType.CALL, self._seqid)
    args = tm_set_negative_mirror_dest_args()
    args.dev = dev
    args.pipe = pipe
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_negative_mirror_dest(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_negative_mirror_dest_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_q_pfc_cos_mapping(self, dev, port, q, cos):
    """
    Parameters:
     - dev
     - port
     - q
     - cos
    """
    self.send_tm_set_q_pfc_cos_mapping(dev, port, q, cos)
    self.recv_tm_set_q_pfc_cos_mapping()

  def send_tm_set_q_pfc_cos_mapping(self, dev, port, q, cos):
    self._oprot.writeMessageBegin('tm_set_q_pfc_cos_mapping', TMessageType.CALL, self._seqid)
    args = tm_set_q_pfc_cos_mapping_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.cos = cos
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_q_pfc_cos_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_q_pfc_cos_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_app_pool_size(self, dev, pool, cells):
    """
    Parameters:
     - dev
     - pool
     - cells
    """
    self.send_tm_set_app_pool_size(dev, pool, cells)
    self.recv_tm_set_app_pool_size()

  def send_tm_set_app_pool_size(self, dev, pool, cells):
    self._oprot.writeMessageBegin('tm_set_app_pool_size', TMessageType.CALL, self._seqid)
    args = tm_set_app_pool_size_args()
    args.dev = dev
    args.pool = pool
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_app_pool_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_app_pool_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_enable_app_pool_color_drop(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    self.send_tm_enable_app_pool_color_drop(dev, pool)
    self.recv_tm_enable_app_pool_color_drop()

  def send_tm_enable_app_pool_color_drop(self, dev, pool):
    self._oprot.writeMessageBegin('tm_enable_app_pool_color_drop', TMessageType.CALL, self._seqid)
    args = tm_enable_app_pool_color_drop_args()
    args.dev = dev
    args.pool = pool
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_enable_app_pool_color_drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_enable_app_pool_color_drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_app_pool_color_drop(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    self.send_tm_disable_app_pool_color_drop(dev, pool)
    self.recv_tm_disable_app_pool_color_drop()

  def send_tm_disable_app_pool_color_drop(self, dev, pool):
    self._oprot.writeMessageBegin('tm_disable_app_pool_color_drop', TMessageType.CALL, self._seqid)
    args = tm_disable_app_pool_color_drop_args()
    args.dev = dev
    args.pool = pool
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_app_pool_color_drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_app_pool_color_drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_app_pool_color_drop_limit(self, dev, pool, color, cells):
    """
    Parameters:
     - dev
     - pool
     - color
     - cells
    """
    self.send_tm_set_app_pool_color_drop_limit(dev, pool, color, cells)
    self.recv_tm_set_app_pool_color_drop_limit()

  def send_tm_set_app_pool_color_drop_limit(self, dev, pool, color, cells):
    self._oprot.writeMessageBegin('tm_set_app_pool_color_drop_limit', TMessageType.CALL, self._seqid)
    args = tm_set_app_pool_color_drop_limit_args()
    args.dev = dev
    args.pool = pool
    args.color = color
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_app_pool_color_drop_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_app_pool_color_drop_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_app_pool_color_drop_hysteresis(self, dev, color, cells):
    """
    Parameters:
     - dev
     - color
     - cells
    """
    self.send_tm_set_app_pool_color_drop_hysteresis(dev, color, cells)
    self.recv_tm_set_app_pool_color_drop_hysteresis()

  def send_tm_set_app_pool_color_drop_hysteresis(self, dev, color, cells):
    self._oprot.writeMessageBegin('tm_set_app_pool_color_drop_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_set_app_pool_color_drop_hysteresis_args()
    args.dev = dev
    args.color = color
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_app_pool_color_drop_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_app_pool_color_drop_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_app_pool_pfc_limit(self, dev, pool, icos, cells):
    """
    Parameters:
     - dev
     - pool
     - icos
     - cells
    """
    self.send_tm_set_app_pool_pfc_limit(dev, pool, icos, cells)
    self.recv_tm_set_app_pool_pfc_limit()

  def send_tm_set_app_pool_pfc_limit(self, dev, pool, icos, cells):
    self._oprot.writeMessageBegin('tm_set_app_pool_pfc_limit', TMessageType.CALL, self._seqid)
    args = tm_set_app_pool_pfc_limit_args()
    args.dev = dev
    args.pool = pool
    args.icos = icos
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_app_pool_pfc_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_app_pool_pfc_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_skid_pool_size(self, dev, cells):
    """
    Parameters:
     - dev
     - cells
    """
    self.send_tm_set_skid_pool_size(dev, cells)
    self.recv_tm_set_skid_pool_size()

  def send_tm_set_skid_pool_size(self, dev, cells):
    self._oprot.writeMessageBegin('tm_set_skid_pool_size', TMessageType.CALL, self._seqid)
    args = tm_set_skid_pool_size_args()
    args.dev = dev
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_skid_pool_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_skid_pool_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_skid_pool_hysteresis(self, dev, cells):
    """
    Parameters:
     - dev
     - cells
    """
    self.send_tm_set_skid_pool_hysteresis(dev, cells)
    self.recv_tm_set_skid_pool_hysteresis()

  def send_tm_set_skid_pool_hysteresis(self, dev, cells):
    self._oprot.writeMessageBegin('tm_set_skid_pool_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_set_skid_pool_hysteresis_args()
    args.dev = dev
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_skid_pool_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_skid_pool_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_negative_mirror_pool_size(self, dev, cells):
    """
    Parameters:
     - dev
     - cells
    """
    self.send_tm_set_negative_mirror_pool_size(dev, cells)
    self.recv_tm_set_negative_mirror_pool_size()

  def send_tm_set_negative_mirror_pool_size(self, dev, cells):
    self._oprot.writeMessageBegin('tm_set_negative_mirror_pool_size', TMessageType.CALL, self._seqid)
    args = tm_set_negative_mirror_pool_size_args()
    args.dev = dev
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_negative_mirror_pool_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_negative_mirror_pool_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_uc_cut_through_pool_size(self, dev, cells):
    """
    Parameters:
     - dev
     - cells
    """
    self.send_tm_set_uc_cut_through_pool_size(dev, cells)
    self.recv_tm_set_uc_cut_through_pool_size()

  def send_tm_set_uc_cut_through_pool_size(self, dev, cells):
    self._oprot.writeMessageBegin('tm_set_uc_cut_through_pool_size', TMessageType.CALL, self._seqid)
    args = tm_set_uc_cut_through_pool_size_args()
    args.dev = dev
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_uc_cut_through_pool_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_uc_cut_through_pool_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_mc_cut_through_pool_size(self, dev, cells):
    """
    Parameters:
     - dev
     - cells
    """
    self.send_tm_set_mc_cut_through_pool_size(dev, cells)
    self.recv_tm_set_mc_cut_through_pool_size()

  def send_tm_set_mc_cut_through_pool_size(self, dev, cells):
    self._oprot.writeMessageBegin('tm_set_mc_cut_through_pool_size', TMessageType.CALL, self._seqid)
    args = tm_set_mc_cut_through_pool_size_args()
    args.dev = dev
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_mc_cut_through_pool_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_mc_cut_through_pool_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_egress_pipe_limit(self, dev, pipe, cells):
    """
    Parameters:
     - dev
     - pipe
     - cells
    """
    self.send_tm_set_egress_pipe_limit(dev, pipe, cells)
    self.recv_tm_set_egress_pipe_limit()

  def send_tm_set_egress_pipe_limit(self, dev, pipe, cells):
    self._oprot.writeMessageBegin('tm_set_egress_pipe_limit', TMessageType.CALL, self._seqid)
    args = tm_set_egress_pipe_limit_args()
    args.dev = dev
    args.pipe = pipe
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_egress_pipe_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_egress_pipe_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_egress_pipe_hysteresis(self, dev, pipe, cells):
    """
    Parameters:
     - dev
     - pipe
     - cells
    """
    self.send_tm_set_egress_pipe_hysteresis(dev, pipe, cells)
    self.recv_tm_set_egress_pipe_hysteresis()

  def send_tm_set_egress_pipe_hysteresis(self, dev, pipe, cells):
    self._oprot.writeMessageBegin('tm_set_egress_pipe_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_set_egress_pipe_hysteresis_args()
    args.dev = dev
    args.pipe = pipe
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_egress_pipe_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_egress_pipe_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_ingress_port_drop_limit(self, dev, port, cells):
    """
    Parameters:
     - dev
     - port
     - cells
    """
    self.send_tm_set_ingress_port_drop_limit(dev, port, cells)
    self.recv_tm_set_ingress_port_drop_limit()

  def send_tm_set_ingress_port_drop_limit(self, dev, port, cells):
    self._oprot.writeMessageBegin('tm_set_ingress_port_drop_limit', TMessageType.CALL, self._seqid)
    args = tm_set_ingress_port_drop_limit_args()
    args.dev = dev
    args.port = port
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_ingress_port_drop_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_ingress_port_drop_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_ingress_port_hysteresis(self, dev, port, cells):
    """
    Parameters:
     - dev
     - port
     - cells
    """
    self.send_tm_set_ingress_port_hysteresis(dev, port, cells)
    self.recv_tm_set_ingress_port_hysteresis()

  def send_tm_set_ingress_port_hysteresis(self, dev, port, cells):
    self._oprot.writeMessageBegin('tm_set_ingress_port_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_set_ingress_port_hysteresis_args()
    args.dev = dev
    args.port = port
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_ingress_port_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_ingress_port_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_port_uc_cut_through_limit(self, dev, port, cells):
    """
    Parameters:
     - dev
     - port
     - cells
    """
    self.send_tm_set_port_uc_cut_through_limit(dev, port, cells)
    self.recv_tm_set_port_uc_cut_through_limit()

  def send_tm_set_port_uc_cut_through_limit(self, dev, port, cells):
    self._oprot.writeMessageBegin('tm_set_port_uc_cut_through_limit', TMessageType.CALL, self._seqid)
    args = tm_set_port_uc_cut_through_limit_args()
    args.dev = dev
    args.port = port
    args.cells = cells
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_port_uc_cut_through_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_port_uc_cut_through_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_port_flowcontrol_mode(self, dev, port, fctype):
    """
    Parameters:
     - dev
     - port
     - fctype
    """
    self.send_tm_set_port_flowcontrol_mode(dev, port, fctype)
    self.recv_tm_set_port_flowcontrol_mode()

  def send_tm_set_port_flowcontrol_mode(self, dev, port, fctype):
    self._oprot.writeMessageBegin('tm_set_port_flowcontrol_mode', TMessageType.CALL, self._seqid)
    args = tm_set_port_flowcontrol_mode_args()
    args.dev = dev
    args.port = port
    args.fctype = fctype
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_port_flowcontrol_mode(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_port_flowcontrol_mode_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_port_pfc_cos_mapping(self, dev, port, cos_icos_map):
    """
    Parameters:
     - dev
     - port
     - cos_icos_map
    """
    self.send_tm_set_port_pfc_cos_mapping(dev, port, cos_icos_map)
    self.recv_tm_set_port_pfc_cos_mapping()

  def send_tm_set_port_pfc_cos_mapping(self, dev, port, cos_icos_map):
    self._oprot.writeMessageBegin('tm_set_port_pfc_cos_mapping', TMessageType.CALL, self._seqid)
    args = tm_set_port_pfc_cos_mapping_args()
    args.dev = dev
    args.port = port
    args.cos_icos_map = cos_icos_map
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_port_pfc_cos_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_port_pfc_cos_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_cpuport(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_set_cpuport(dev, port)
    self.recv_tm_set_cpuport()

  def send_tm_set_cpuport(self, dev, port):
    self._oprot.writeMessageBegin('tm_set_cpuport', TMessageType.CALL, self._seqid)
    args = tm_set_cpuport_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_cpuport(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_cpuport_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_reset_cpuport(self, dev):
    """
    Parameters:
     - dev
    """
    self.send_tm_reset_cpuport(dev)
    self.recv_tm_reset_cpuport()

  def send_tm_reset_cpuport(self, dev):
    self._oprot.writeMessageBegin('tm_reset_cpuport', TMessageType.CALL, self._seqid)
    args = tm_reset_cpuport_args()
    args.dev = dev
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_reset_cpuport(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_reset_cpuport_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_q_sched_priority(self, dev, port, q, prio):
    """
    Parameters:
     - dev
     - port
     - q
     - prio
    """
    self.send_tm_set_q_sched_priority(dev, port, q, prio)
    self.recv_tm_set_q_sched_priority()

  def send_tm_set_q_sched_priority(self, dev, port, q, prio):
    self._oprot.writeMessageBegin('tm_set_q_sched_priority', TMessageType.CALL, self._seqid)
    args = tm_set_q_sched_priority_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.prio = prio
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_q_sched_priority(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_q_sched_priority_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_q_dwrr_weight(self, dev, port, q, weight):
    """
    Parameters:
     - dev
     - port
     - q
     - weight
    """
    self.send_tm_set_q_dwrr_weight(dev, port, q, weight)
    self.recv_tm_set_q_dwrr_weight()

  def send_tm_set_q_dwrr_weight(self, dev, port, q, weight):
    self._oprot.writeMessageBegin('tm_set_q_dwrr_weight', TMessageType.CALL, self._seqid)
    args = tm_set_q_dwrr_weight_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.weight = weight
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_q_dwrr_weight(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_q_dwrr_weight_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_q_shaping_rate(self, dev, port, q, pps, burstsize, rate):
    """
    Parameters:
     - dev
     - port
     - q
     - pps
     - burstsize
     - rate
    """
    self.send_tm_set_q_shaping_rate(dev, port, q, pps, burstsize, rate)
    self.recv_tm_set_q_shaping_rate()

  def send_tm_set_q_shaping_rate(self, dev, port, q, pps, burstsize, rate):
    self._oprot.writeMessageBegin('tm_set_q_shaping_rate', TMessageType.CALL, self._seqid)
    args = tm_set_q_shaping_rate_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.pps = pps
    args.burstsize = burstsize
    args.rate = rate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_q_shaping_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_q_shaping_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_q_guaranteed_rate(self, dev, port, q, pps, burstsize, rate):
    """
    Parameters:
     - dev
     - port
     - q
     - pps
     - burstsize
     - rate
    """
    self.send_tm_set_q_guaranteed_rate(dev, port, q, pps, burstsize, rate)
    self.recv_tm_set_q_guaranteed_rate()

  def send_tm_set_q_guaranteed_rate(self, dev, port, q, pps, burstsize, rate):
    self._oprot.writeMessageBegin('tm_set_q_guaranteed_rate', TMessageType.CALL, self._seqid)
    args = tm_set_q_guaranteed_rate_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.pps = pps
    args.burstsize = burstsize
    args.rate = rate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_q_guaranteed_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_q_guaranteed_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_q_remaining_bw_sched_priority(self, dev, port, q, prio):
    """
    Parameters:
     - dev
     - port
     - q
     - prio
    """
    self.send_tm_set_q_remaining_bw_sched_priority(dev, port, q, prio)
    self.recv_tm_set_q_remaining_bw_sched_priority()

  def send_tm_set_q_remaining_bw_sched_priority(self, dev, port, q, prio):
    self._oprot.writeMessageBegin('tm_set_q_remaining_bw_sched_priority', TMessageType.CALL, self._seqid)
    args = tm_set_q_remaining_bw_sched_priority_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.prio = prio
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_q_remaining_bw_sched_priority(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_q_remaining_bw_sched_priority_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_q_l1_set(self, dev, port, l1_node, q):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - q
    """
    self.send_tm_sched_q_l1_set(dev, port, l1_node, q)
    self.recv_tm_sched_q_l1_set()

  def send_tm_sched_q_l1_set(self, dev, port, l1_node, q):
    self._oprot.writeMessageBegin('tm_sched_q_l1_set', TMessageType.CALL, self._seqid)
    args = tm_sched_q_l1_set_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_q_l1_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_q_l1_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_q_l1_reset(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_sched_q_l1_reset(dev, port, q)
    self.recv_tm_sched_q_l1_reset()

  def send_tm_sched_q_l1_reset(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_sched_q_l1_reset', TMessageType.CALL, self._seqid)
    args = tm_sched_q_l1_reset_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_q_l1_reset(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_q_l1_reset_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_priority_set(self, dev, port, l1_node, priority):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - priority
    """
    self.send_tm_sched_l1_priority_set(dev, port, l1_node, priority)
    self.recv_tm_sched_l1_priority_set()

  def send_tm_sched_l1_priority_set(self, dev, port, l1_node, priority):
    self._oprot.writeMessageBegin('tm_sched_l1_priority_set', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_priority_set_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.priority = priority
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_priority_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_priority_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_dwrr_weight_set(self, dev, port, l1_node, weight):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - weight
    """
    self.send_tm_sched_l1_dwrr_weight_set(dev, port, l1_node, weight)
    self.recv_tm_sched_l1_dwrr_weight_set()

  def send_tm_sched_l1_dwrr_weight_set(self, dev, port, l1_node, weight):
    self._oprot.writeMessageBegin('tm_sched_l1_dwrr_weight_set', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_dwrr_weight_set_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.weight = weight
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_dwrr_weight_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_dwrr_weight_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_shaping_rate_set(self, dev, port, l1_node, pps, burst_size, rate):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - pps
     - burst_size
     - rate
    """
    self.send_tm_sched_l1_shaping_rate_set(dev, port, l1_node, pps, burst_size, rate)
    self.recv_tm_sched_l1_shaping_rate_set()

  def send_tm_sched_l1_shaping_rate_set(self, dev, port, l1_node, pps, burst_size, rate):
    self._oprot.writeMessageBegin('tm_sched_l1_shaping_rate_set', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_shaping_rate_set_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.pps = pps
    args.burst_size = burst_size
    args.rate = rate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_shaping_rate_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_shaping_rate_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_max_shaping_rate_enable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    self.send_tm_sched_l1_max_shaping_rate_enable(dev, port, l1_node)
    self.recv_tm_sched_l1_max_shaping_rate_enable()

  def send_tm_sched_l1_max_shaping_rate_enable(self, dev, port, l1_node):
    self._oprot.writeMessageBegin('tm_sched_l1_max_shaping_rate_enable', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_max_shaping_rate_enable_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_max_shaping_rate_enable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_max_shaping_rate_enable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_max_shaping_rate_disable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    self.send_tm_sched_l1_max_shaping_rate_disable(dev, port, l1_node)
    self.recv_tm_sched_l1_max_shaping_rate_disable()

  def send_tm_sched_l1_max_shaping_rate_disable(self, dev, port, l1_node):
    self._oprot.writeMessageBegin('tm_sched_l1_max_shaping_rate_disable', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_max_shaping_rate_disable_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_max_shaping_rate_disable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_max_shaping_rate_disable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_priority_prop_enable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    self.send_tm_sched_l1_priority_prop_enable(dev, port, l1_node)
    self.recv_tm_sched_l1_priority_prop_enable()

  def send_tm_sched_l1_priority_prop_enable(self, dev, port, l1_node):
    self._oprot.writeMessageBegin('tm_sched_l1_priority_prop_enable', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_priority_prop_enable_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_priority_prop_enable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_priority_prop_enable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_priority_prop_disable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    self.send_tm_sched_l1_priority_prop_disable(dev, port, l1_node)
    self.recv_tm_sched_l1_priority_prop_disable()

  def send_tm_sched_l1_priority_prop_disable(self, dev, port, l1_node):
    self._oprot.writeMessageBegin('tm_sched_l1_priority_prop_disable', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_priority_prop_disable_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_priority_prop_disable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_priority_prop_disable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_guaranteed_rate_set(self, dev, port, l1_node, pps, burst_size, rate):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - pps
     - burst_size
     - rate
    """
    self.send_tm_sched_l1_guaranteed_rate_set(dev, port, l1_node, pps, burst_size, rate)
    self.recv_tm_sched_l1_guaranteed_rate_set()

  def send_tm_sched_l1_guaranteed_rate_set(self, dev, port, l1_node, pps, burst_size, rate):
    self._oprot.writeMessageBegin('tm_sched_l1_guaranteed_rate_set', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_guaranteed_rate_set_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.pps = pps
    args.burst_size = burst_size
    args.rate = rate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_guaranteed_rate_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_guaranteed_rate_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_remaining_bw_priority_set(self, dev, port, l1_node, priority):
    """
    Parameters:
     - dev
     - port
     - l1_node
     - priority
    """
    self.send_tm_sched_l1_remaining_bw_priority_set(dev, port, l1_node, priority)
    self.recv_tm_sched_l1_remaining_bw_priority_set()

  def send_tm_sched_l1_remaining_bw_priority_set(self, dev, port, l1_node, priority):
    self._oprot.writeMessageBegin('tm_sched_l1_remaining_bw_priority_set', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_remaining_bw_priority_set_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.priority = priority
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_remaining_bw_priority_set(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_remaining_bw_priority_set_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_guaranteed_rate_enable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    self.send_tm_sched_l1_guaranteed_rate_enable(dev, port, l1_node)
    self.recv_tm_sched_l1_guaranteed_rate_enable()

  def send_tm_sched_l1_guaranteed_rate_enable(self, dev, port, l1_node):
    self._oprot.writeMessageBegin('tm_sched_l1_guaranteed_rate_enable', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_guaranteed_rate_enable_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_guaranteed_rate_enable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_guaranteed_rate_enable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_guaranteed_rate_disable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    self.send_tm_sched_l1_guaranteed_rate_disable(dev, port, l1_node)
    self.recv_tm_sched_l1_guaranteed_rate_disable()

  def send_tm_sched_l1_guaranteed_rate_disable(self, dev, port, l1_node):
    self._oprot.writeMessageBegin('tm_sched_l1_guaranteed_rate_disable', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_guaranteed_rate_disable_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_guaranteed_rate_disable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_guaranteed_rate_disable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_enable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    self.send_tm_sched_l1_enable(dev, port, l1_node)
    self.recv_tm_sched_l1_enable()

  def send_tm_sched_l1_enable(self, dev, port, l1_node):
    self._oprot.writeMessageBegin('tm_sched_l1_enable', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_enable_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_enable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_enable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_disable(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    self.send_tm_sched_l1_disable(dev, port, l1_node)
    self.recv_tm_sched_l1_disable()

  def send_tm_sched_l1_disable(self, dev, port, l1_node):
    self._oprot.writeMessageBegin('tm_sched_l1_disable', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_disable_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_disable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_disable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_sched_l1_free(self, dev, port, l1_node):
    """
    Parameters:
     - dev
     - port
     - l1_node
    """
    self.send_tm_sched_l1_free(dev, port, l1_node)
    self.recv_tm_sched_l1_free()

  def send_tm_sched_l1_free(self, dev, port, l1_node):
    self._oprot.writeMessageBegin('tm_sched_l1_free', TMessageType.CALL, self._seqid)
    args = tm_sched_l1_free_args()
    args.dev = dev
    args.port = port
    args.l1_node = l1_node
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_sched_l1_free(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_sched_l1_free_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_port_shaping_rate(self, dev, port, pps, burstsize, rate):
    """
    Parameters:
     - dev
     - port
     - pps
     - burstsize
     - rate
    """
    self.send_tm_set_port_shaping_rate(dev, port, pps, burstsize, rate)
    self.recv_tm_set_port_shaping_rate()

  def send_tm_set_port_shaping_rate(self, dev, port, pps, burstsize, rate):
    self._oprot.writeMessageBegin('tm_set_port_shaping_rate', TMessageType.CALL, self._seqid)
    args = tm_set_port_shaping_rate_args()
    args.dev = dev
    args.port = port
    args.pps = pps
    args.burstsize = burstsize
    args.rate = rate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_port_shaping_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_port_shaping_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_shaper_pkt_ifg_compensation(self, dev, pipe, adjustment):
    """
    Parameters:
     - dev
     - pipe
     - adjustment
    """
    self.send_tm_set_shaper_pkt_ifg_compensation(dev, pipe, adjustment)
    self.recv_tm_set_shaper_pkt_ifg_compensation()

  def send_tm_set_shaper_pkt_ifg_compensation(self, dev, pipe, adjustment):
    self._oprot.writeMessageBegin('tm_set_shaper_pkt_ifg_compensation', TMessageType.CALL, self._seqid)
    args = tm_set_shaper_pkt_ifg_compensation_args()
    args.dev = dev
    args.pipe = pipe
    args.adjustment = adjustment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_shaper_pkt_ifg_compensation(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_shaper_pkt_ifg_compensation_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_enable_q_sched(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_enable_q_sched(dev, port, q)
    self.recv_tm_enable_q_sched()

  def send_tm_enable_q_sched(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_enable_q_sched', TMessageType.CALL, self._seqid)
    args = tm_enable_q_sched_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_enable_q_sched(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_enable_q_sched_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_q_sched(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_disable_q_sched(dev, port, q)
    self.recv_tm_disable_q_sched()

  def send_tm_disable_q_sched(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_disable_q_sched', TMessageType.CALL, self._seqid)
    args = tm_disable_q_sched_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_q_sched(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_q_sched_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_enable_port_shaping(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_enable_port_shaping(dev, port)
    self.recv_tm_enable_port_shaping()

  def send_tm_enable_port_shaping(self, dev, port):
    self._oprot.writeMessageBegin('tm_enable_port_shaping', TMessageType.CALL, self._seqid)
    args = tm_enable_port_shaping_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_enable_port_shaping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_enable_port_shaping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_port_shaping(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_disable_port_shaping(dev, port)
    self.recv_tm_disable_port_shaping()

  def send_tm_disable_port_shaping(self, dev, port):
    self._oprot.writeMessageBegin('tm_disable_port_shaping', TMessageType.CALL, self._seqid)
    args = tm_disable_port_shaping_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_port_shaping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_port_shaping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_enable_port_sched(self, dev, port, speed):
    """
    Parameters:
     - dev
     - port
     - speed
    """
    self.send_tm_enable_port_sched(dev, port, speed)
    self.recv_tm_enable_port_sched()

  def send_tm_enable_port_sched(self, dev, port, speed):
    self._oprot.writeMessageBegin('tm_enable_port_sched', TMessageType.CALL, self._seqid)
    args = tm_enable_port_sched_args()
    args.dev = dev
    args.port = port
    args.speed = speed
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_enable_port_sched(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_enable_port_sched_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_port_sched(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_disable_port_sched(dev, port)
    self.recv_tm_disable_port_sched()

  def send_tm_disable_port_sched(self, dev, port):
    self._oprot.writeMessageBegin('tm_disable_port_sched', TMessageType.CALL, self._seqid)
    args = tm_disable_port_sched_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_port_sched(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_port_sched_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_enable_q_max_shaping_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_enable_q_max_shaping_rate(dev, port, q)
    self.recv_tm_enable_q_max_shaping_rate()

  def send_tm_enable_q_max_shaping_rate(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_enable_q_max_shaping_rate', TMessageType.CALL, self._seqid)
    args = tm_enable_q_max_shaping_rate_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_enable_q_max_shaping_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_enable_q_max_shaping_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_q_max_shaping_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_disable_q_max_shaping_rate(dev, port, q)
    self.recv_tm_disable_q_max_shaping_rate()

  def send_tm_disable_q_max_shaping_rate(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_disable_q_max_shaping_rate', TMessageType.CALL, self._seqid)
    args = tm_disable_q_max_shaping_rate_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_q_max_shaping_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_q_max_shaping_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_enable_q_min_shaping_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_enable_q_min_shaping_rate(dev, port, q)
    self.recv_tm_enable_q_min_shaping_rate()

  def send_tm_enable_q_min_shaping_rate(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_enable_q_min_shaping_rate', TMessageType.CALL, self._seqid)
    args = tm_enable_q_min_shaping_rate_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_enable_q_min_shaping_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_enable_q_min_shaping_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_disable_q_min_shaping_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_disable_q_min_shaping_rate(dev, port, q)
    self.recv_tm_disable_q_min_shaping_rate()

  def send_tm_disable_q_min_shaping_rate(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_disable_q_min_shaping_rate', TMessageType.CALL, self._seqid)
    args = tm_disable_q_min_shaping_rate_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_disable_q_min_shaping_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_disable_q_min_shaping_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_complete_operations(self, dev):
    """
    Parameters:
     - dev
    """
    self.send_tm_complete_operations(dev)
    self.recv_tm_complete_operations()

  def send_tm_complete_operations(self, dev):
    self._oprot.writeMessageBegin('tm_complete_operations', TMessageType.CALL, self._seqid)
    args = tm_complete_operations_args()
    args.dev = dev
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_complete_operations(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_complete_operations_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_timestamp_shift(self, dev, shift):
    """
    Parameters:
     - dev
     - shift
    """
    self.send_tm_set_timestamp_shift(dev, shift)
    self.recv_tm_set_timestamp_shift()

  def send_tm_set_timestamp_shift(self, dev, shift):
    self._oprot.writeMessageBegin('tm_set_timestamp_shift', TMessageType.CALL, self._seqid)
    args = tm_set_timestamp_shift_args()
    args.dev = dev
    args.shift = shift
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_timestamp_shift(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_timestamp_shift_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_get_q_sched_priority(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_get_q_sched_priority(dev, port, q)
    return self.recv_tm_get_q_sched_priority()

  def send_tm_get_q_sched_priority(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_get_q_sched_priority', TMessageType.CALL, self._seqid)
    args = tm_get_q_sched_priority_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_sched_priority(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_sched_priority_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_sched_priority failed: unknown result");

  def tm_get_q_dwrr_weight(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_get_q_dwrr_weight(dev, port, q)
    return self.recv_tm_get_q_dwrr_weight()

  def send_tm_get_q_dwrr_weight(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_get_q_dwrr_weight', TMessageType.CALL, self._seqid)
    args = tm_get_q_dwrr_weight_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_dwrr_weight(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_dwrr_weight_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_dwrr_weight failed: unknown result");

  def tm_get_q_shaping_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_get_q_shaping_rate(dev, port, q)
    return self.recv_tm_get_q_shaping_rate()

  def send_tm_get_q_shaping_rate(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_get_q_shaping_rate', TMessageType.CALL, self._seqid)
    args = tm_get_q_shaping_rate_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_shaping_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_shaping_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_shaping_rate failed: unknown result");

  def tm_get_q_guaranteed_rate(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_get_q_guaranteed_rate(dev, port, q)
    return self.recv_tm_get_q_guaranteed_rate()

  def send_tm_get_q_guaranteed_rate(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_get_q_guaranteed_rate', TMessageType.CALL, self._seqid)
    args = tm_get_q_guaranteed_rate_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_guaranteed_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_guaranteed_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_guaranteed_rate failed: unknown result");

  def tm_get_q_remaining_bw_sched_priority(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_get_q_remaining_bw_sched_priority(dev, port, q)
    return self.recv_tm_get_q_remaining_bw_sched_priority()

  def send_tm_get_q_remaining_bw_sched_priority(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_get_q_remaining_bw_sched_priority', TMessageType.CALL, self._seqid)
    args = tm_get_q_remaining_bw_sched_priority_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_remaining_bw_sched_priority(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_remaining_bw_sched_priority_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_remaining_bw_sched_priority failed: unknown result");

  def tm_get_port_shaping_rate(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_get_port_shaping_rate(dev, port)
    return self.recv_tm_get_port_shaping_rate()

  def send_tm_get_port_shaping_rate(self, dev, port):
    self._oprot.writeMessageBegin('tm_get_port_shaping_rate', TMessageType.CALL, self._seqid)
    args = tm_get_port_shaping_rate_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_port_shaping_rate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_port_shaping_rate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_port_shaping_rate failed: unknown result");

  def tm_get_shaper_pkt_ifg_compensation(self, dev, pipe):
    """
    Parameters:
     - dev
     - pipe
    """
    self.send_tm_get_shaper_pkt_ifg_compensation(dev, pipe)
    return self.recv_tm_get_shaper_pkt_ifg_compensation()

  def send_tm_get_shaper_pkt_ifg_compensation(self, dev, pipe):
    self._oprot.writeMessageBegin('tm_get_shaper_pkt_ifg_compensation', TMessageType.CALL, self._seqid)
    args = tm_get_shaper_pkt_ifg_compensation_args()
    args.dev = dev
    args.pipe = pipe
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_shaper_pkt_ifg_compensation(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_shaper_pkt_ifg_compensation_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_shaper_pkt_ifg_compensation failed: unknown result");

  def tm_get_egress_pipe_limit(self, dev, pipe):
    """
    Parameters:
     - dev
     - pipe
    """
    self.send_tm_get_egress_pipe_limit(dev, pipe)
    return self.recv_tm_get_egress_pipe_limit()

  def send_tm_get_egress_pipe_limit(self, dev, pipe):
    self._oprot.writeMessageBegin('tm_get_egress_pipe_limit', TMessageType.CALL, self._seqid)
    args = tm_get_egress_pipe_limit_args()
    args.dev = dev
    args.pipe = pipe
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_egress_pipe_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_egress_pipe_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_egress_pipe_limit failed: unknown result");

  def tm_get_egress_pipe_hysteresis(self, dev, pipe):
    """
    Parameters:
     - dev
     - pipe
    """
    self.send_tm_get_egress_pipe_hysteresis(dev, pipe)
    return self.recv_tm_get_egress_pipe_hysteresis()

  def send_tm_get_egress_pipe_hysteresis(self, dev, pipe):
    self._oprot.writeMessageBegin('tm_get_egress_pipe_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_get_egress_pipe_hysteresis_args()
    args.dev = dev
    args.pipe = pipe
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_egress_pipe_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_egress_pipe_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_egress_pipe_hysteresis failed: unknown result");

  def tm_get_port_q_mapping(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_get_port_q_mapping(dev, port)
    return self.recv_tm_get_port_q_mapping()

  def send_tm_get_port_q_mapping(self, dev, port):
    self._oprot.writeMessageBegin('tm_get_port_q_mapping', TMessageType.CALL, self._seqid)
    args = tm_get_port_q_mapping_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_port_q_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_port_q_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_port_q_mapping failed: unknown result");

  def tm_get_q_app_pool_usage(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_get_q_app_pool_usage(dev, port, q)
    return self.recv_tm_get_q_app_pool_usage()

  def send_tm_get_q_app_pool_usage(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_get_q_app_pool_usage', TMessageType.CALL, self._seqid)
    args = tm_get_q_app_pool_usage_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_app_pool_usage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_app_pool_usage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_app_pool_usage failed: unknown result");

  def tm_get_q_guaranteed_min_limit(self, dev, port, q):
    """
    Parameters:
     - dev
     - port
     - q
    """
    self.send_tm_get_q_guaranteed_min_limit(dev, port, q)
    return self.recv_tm_get_q_guaranteed_min_limit()

  def send_tm_get_q_guaranteed_min_limit(self, dev, port, q):
    self._oprot.writeMessageBegin('tm_get_q_guaranteed_min_limit', TMessageType.CALL, self._seqid)
    args = tm_get_q_guaranteed_min_limit_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_guaranteed_min_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_guaranteed_min_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_guaranteed_min_limit failed: unknown result");

  def tm_get_q_color_limit(self, dev, port, q, color):
    """
    Parameters:
     - dev
     - port
     - q
     - color
    """
    self.send_tm_get_q_color_limit(dev, port, q, color)
    return self.recv_tm_get_q_color_limit()

  def send_tm_get_q_color_limit(self, dev, port, q, color):
    self._oprot.writeMessageBegin('tm_get_q_color_limit', TMessageType.CALL, self._seqid)
    args = tm_get_q_color_limit_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.color = color
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_color_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_color_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_color_limit failed: unknown result");

  def tm_get_q_color_hysteresis(self, dev, port, q, color):
    """
    Parameters:
     - dev
     - port
     - q
     - color
    """
    self.send_tm_get_q_color_hysteresis(dev, port, q, color)
    return self.recv_tm_get_q_color_hysteresis()

  def send_tm_get_q_color_hysteresis(self, dev, port, q, color):
    self._oprot.writeMessageBegin('tm_get_q_color_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_get_q_color_hysteresis_args()
    args.dev = dev
    args.port = port
    args.q = q
    args.color = color
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_color_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_color_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_color_hysteresis failed: unknown result");

  def tm_get_port_uc_cut_through_limit(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_get_port_uc_cut_through_limit(dev, port)
    return self.recv_tm_get_port_uc_cut_through_limit()

  def send_tm_get_port_uc_cut_through_limit(self, dev, port):
    self._oprot.writeMessageBegin('tm_get_port_uc_cut_through_limit', TMessageType.CALL, self._seqid)
    args = tm_get_port_uc_cut_through_limit_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_port_uc_cut_through_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_port_uc_cut_through_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_port_uc_cut_through_limit failed: unknown result");

  def tm_get_total_ppg(self, dev, pipe):
    """
    Parameters:
     - dev
     - pipe
    """
    self.send_tm_get_total_ppg(dev, pipe)
    return self.recv_tm_get_total_ppg()

  def send_tm_get_total_ppg(self, dev, pipe):
    self._oprot.writeMessageBegin('tm_get_total_ppg', TMessageType.CALL, self._seqid)
    args = tm_get_total_ppg_args()
    args.dev = dev
    args.pipe = pipe
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_total_ppg(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_total_ppg_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_total_ppg failed: unknown result");

  def tm_get_unused_ppg_count(self, dev, pipe):
    """
    Parameters:
     - dev
     - pipe
    """
    self.send_tm_get_unused_ppg_count(dev, pipe)
    return self.recv_tm_get_unused_ppg_count()

  def send_tm_get_unused_ppg_count(self, dev, pipe):
    self._oprot.writeMessageBegin('tm_get_unused_ppg_count', TMessageType.CALL, self._seqid)
    args = tm_get_unused_ppg_count_args()
    args.dev = dev
    args.pipe = pipe
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_unused_ppg_count(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_unused_ppg_count_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_unused_ppg_count failed: unknown result");

  def tm_get_ppg_app_pool_usage(self, dev, ppg, pool):
    """
    Parameters:
     - dev
     - ppg
     - pool
    """
    self.send_tm_get_ppg_app_pool_usage(dev, ppg, pool)
    return self.recv_tm_get_ppg_app_pool_usage()

  def send_tm_get_ppg_app_pool_usage(self, dev, ppg, pool):
    self._oprot.writeMessageBegin('tm_get_ppg_app_pool_usage', TMessageType.CALL, self._seqid)
    args = tm_get_ppg_app_pool_usage_args()
    args.dev = dev
    args.ppg = ppg
    args.pool = pool
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_ppg_app_pool_usage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_ppg_app_pool_usage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_ppg_app_pool_usage failed: unknown result");

  def tm_get_ppg_guaranteed_min_limit(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    self.send_tm_get_ppg_guaranteed_min_limit(dev, ppg)
    return self.recv_tm_get_ppg_guaranteed_min_limit()

  def send_tm_get_ppg_guaranteed_min_limit(self, dev, ppg):
    self._oprot.writeMessageBegin('tm_get_ppg_guaranteed_min_limit', TMessageType.CALL, self._seqid)
    args = tm_get_ppg_guaranteed_min_limit_args()
    args.dev = dev
    args.ppg = ppg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_ppg_guaranteed_min_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_ppg_guaranteed_min_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_ppg_guaranteed_min_limit failed: unknown result");

  def tm_get_ppg_skid_limit(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    self.send_tm_get_ppg_skid_limit(dev, ppg)
    return self.recv_tm_get_ppg_skid_limit()

  def send_tm_get_ppg_skid_limit(self, dev, ppg):
    self._oprot.writeMessageBegin('tm_get_ppg_skid_limit', TMessageType.CALL, self._seqid)
    args = tm_get_ppg_skid_limit_args()
    args.dev = dev
    args.ppg = ppg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_ppg_skid_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_ppg_skid_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_ppg_skid_limit failed: unknown result");

  def tm_get_ppg_guaranteed_min_skid_hysteresis(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    self.send_tm_get_ppg_guaranteed_min_skid_hysteresis(dev, ppg)
    return self.recv_tm_get_ppg_guaranteed_min_skid_hysteresis()

  def send_tm_get_ppg_guaranteed_min_skid_hysteresis(self, dev, ppg):
    self._oprot.writeMessageBegin('tm_get_ppg_guaranteed_min_skid_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_get_ppg_guaranteed_min_skid_hysteresis_args()
    args.dev = dev
    args.ppg = ppg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_ppg_guaranteed_min_skid_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_ppg_guaranteed_min_skid_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_ppg_guaranteed_min_skid_hysteresis failed: unknown result");

  def tm_get_app_pool_size(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    self.send_tm_get_app_pool_size(dev, pool)
    return self.recv_tm_get_app_pool_size()

  def send_tm_get_app_pool_size(self, dev, pool):
    self._oprot.writeMessageBegin('tm_get_app_pool_size', TMessageType.CALL, self._seqid)
    args = tm_get_app_pool_size_args()
    args.dev = dev
    args.pool = pool
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_app_pool_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_app_pool_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_app_pool_size failed: unknown result");

  def tm_get_app_pool_color_drop_limit(self, dev, pool, color):
    """
    Parameters:
     - dev
     - pool
     - color
    """
    self.send_tm_get_app_pool_color_drop_limit(dev, pool, color)
    return self.recv_tm_get_app_pool_color_drop_limit()

  def send_tm_get_app_pool_color_drop_limit(self, dev, pool, color):
    self._oprot.writeMessageBegin('tm_get_app_pool_color_drop_limit', TMessageType.CALL, self._seqid)
    args = tm_get_app_pool_color_drop_limit_args()
    args.dev = dev
    args.pool = pool
    args.color = color
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_app_pool_color_drop_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_app_pool_color_drop_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_app_pool_color_drop_limit failed: unknown result");

  def tm_get_app_pool_color_drop_hysteresis(self, dev, color):
    """
    Parameters:
     - dev
     - color
    """
    self.send_tm_get_app_pool_color_drop_hysteresis(dev, color)
    return self.recv_tm_get_app_pool_color_drop_hysteresis()

  def send_tm_get_app_pool_color_drop_hysteresis(self, dev, color):
    self._oprot.writeMessageBegin('tm_get_app_pool_color_drop_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_get_app_pool_color_drop_hysteresis_args()
    args.dev = dev
    args.color = color
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_app_pool_color_drop_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_app_pool_color_drop_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_app_pool_color_drop_hysteresis failed: unknown result");

  def tm_get_app_pool_pfc_limit(self, dev, pool, icos):
    """
    Parameters:
     - dev
     - pool
     - icos
    """
    self.send_tm_get_app_pool_pfc_limit(dev, pool, icos)
    return self.recv_tm_get_app_pool_pfc_limit()

  def send_tm_get_app_pool_pfc_limit(self, dev, pool, icos):
    self._oprot.writeMessageBegin('tm_get_app_pool_pfc_limit', TMessageType.CALL, self._seqid)
    args = tm_get_app_pool_pfc_limit_args()
    args.dev = dev
    args.pool = pool
    args.icos = icos
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_app_pool_pfc_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_app_pool_pfc_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_app_pool_pfc_limit failed: unknown result");

  def tm_get_skid_pool_size(self, dev):
    """
    Parameters:
     - dev
    """
    self.send_tm_get_skid_pool_size(dev)
    return self.recv_tm_get_skid_pool_size()

  def send_tm_get_skid_pool_size(self, dev):
    self._oprot.writeMessageBegin('tm_get_skid_pool_size', TMessageType.CALL, self._seqid)
    args = tm_get_skid_pool_size_args()
    args.dev = dev
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_skid_pool_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_skid_pool_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_skid_pool_size failed: unknown result");

  def tm_get_skid_pool_hysteresis(self, dev):
    """
    Parameters:
     - dev
    """
    self.send_tm_get_skid_pool_hysteresis(dev)
    return self.recv_tm_get_skid_pool_hysteresis()

  def send_tm_get_skid_pool_hysteresis(self, dev):
    self._oprot.writeMessageBegin('tm_get_skid_pool_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_get_skid_pool_hysteresis_args()
    args.dev = dev
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_skid_pool_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_skid_pool_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_skid_pool_hysteresis failed: unknown result");

  def tm_get_negative_mirror_pool_size(self, dev):
    """
    Parameters:
     - dev
    """
    self.send_tm_get_negative_mirror_pool_size(dev)
    return self.recv_tm_get_negative_mirror_pool_size()

  def send_tm_get_negative_mirror_pool_size(self, dev):
    self._oprot.writeMessageBegin('tm_get_negative_mirror_pool_size', TMessageType.CALL, self._seqid)
    args = tm_get_negative_mirror_pool_size_args()
    args.dev = dev
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_negative_mirror_pool_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_negative_mirror_pool_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_negative_mirror_pool_size failed: unknown result");

  def tm_get_uc_cut_through_pool_size(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    self.send_tm_get_uc_cut_through_pool_size(dev, pool)
    return self.recv_tm_get_uc_cut_through_pool_size()

  def send_tm_get_uc_cut_through_pool_size(self, dev, pool):
    self._oprot.writeMessageBegin('tm_get_uc_cut_through_pool_size', TMessageType.CALL, self._seqid)
    args = tm_get_uc_cut_through_pool_size_args()
    args.dev = dev
    args.pool = pool
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_uc_cut_through_pool_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_uc_cut_through_pool_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_uc_cut_through_pool_size failed: unknown result");

  def tm_get_mc_cut_through_pool_size(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    self.send_tm_get_mc_cut_through_pool_size(dev, pool)
    return self.recv_tm_get_mc_cut_through_pool_size()

  def send_tm_get_mc_cut_through_pool_size(self, dev, pool):
    self._oprot.writeMessageBegin('tm_get_mc_cut_through_pool_size', TMessageType.CALL, self._seqid)
    args = tm_get_mc_cut_through_pool_size_args()
    args.dev = dev
    args.pool = pool
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_mc_cut_through_pool_size(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_mc_cut_through_pool_size_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_mc_cut_through_pool_size failed: unknown result");

  def tm_get_ingress_port_drop_limit(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_get_ingress_port_drop_limit(dev, port)
    return self.recv_tm_get_ingress_port_drop_limit()

  def send_tm_get_ingress_port_drop_limit(self, dev, port):
    self._oprot.writeMessageBegin('tm_get_ingress_port_drop_limit', TMessageType.CALL, self._seqid)
    args = tm_get_ingress_port_drop_limit_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_ingress_port_drop_limit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_ingress_port_drop_limit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_ingress_port_drop_limit failed: unknown result");

  def tm_get_ingress_port_hysteresis(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_get_ingress_port_hysteresis(dev, port)
    return self.recv_tm_get_ingress_port_hysteresis()

  def send_tm_get_ingress_port_hysteresis(self, dev, port):
    self._oprot.writeMessageBegin('tm_get_ingress_port_hysteresis', TMessageType.CALL, self._seqid)
    args = tm_get_ingress_port_hysteresis_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_ingress_port_hysteresis(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_ingress_port_hysteresis_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_ingress_port_hysteresis failed: unknown result");

  def tm_get_port_flowcontrol_mode(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_get_port_flowcontrol_mode(dev, port)
    return self.recv_tm_get_port_flowcontrol_mode()

  def send_tm_get_port_flowcontrol_mode(self, dev, port):
    self._oprot.writeMessageBegin('tm_get_port_flowcontrol_mode', TMessageType.CALL, self._seqid)
    args = tm_get_port_flowcontrol_mode_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_port_flowcontrol_mode(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_port_flowcontrol_mode_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_port_flowcontrol_mode failed: unknown result");

  def tm_get_port_pfc_cos_mapping(self, dev, port):
    """
    Parameters:
     - dev
     - port
    """
    self.send_tm_get_port_pfc_cos_mapping(dev, port)
    return self.recv_tm_get_port_pfc_cos_mapping()

  def send_tm_get_port_pfc_cos_mapping(self, dev, port):
    self._oprot.writeMessageBegin('tm_get_port_pfc_cos_mapping', TMessageType.CALL, self._seqid)
    args = tm_get_port_pfc_cos_mapping_args()
    args.dev = dev
    args.port = port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_port_pfc_cos_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_port_pfc_cos_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_port_pfc_cos_mapping failed: unknown result");

  def tm_get_ppg_icos_mapping(self, dev, ppg):
    """
    Parameters:
     - dev
     - ppg
    """
    self.send_tm_get_ppg_icos_mapping(dev, ppg)
    return self.recv_tm_get_ppg_icos_mapping()

  def send_tm_get_ppg_icos_mapping(self, dev, ppg):
    self._oprot.writeMessageBegin('tm_get_ppg_icos_mapping', TMessageType.CALL, self._seqid)
    args = tm_get_ppg_icos_mapping_args()
    args.dev = dev
    args.ppg = ppg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_ppg_icos_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_ppg_icos_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_ppg_icos_mapping failed: unknown result");

  def tm_get_timestamp_shift(self, dev):
    """
    Parameters:
     - dev
    """
    self.send_tm_get_timestamp_shift(dev)
    return self.recv_tm_get_timestamp_shift()

  def send_tm_get_timestamp_shift(self, dev):
    self._oprot.writeMessageBegin('tm_get_timestamp_shift', TMessageType.CALL, self._seqid)
    args = tm_get_timestamp_shift_args()
    args.dev = dev
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_timestamp_shift(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_timestamp_shift_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_timestamp_shift failed: unknown result");

  def tm_get_ppg_drop(self, dev, pipe, ppg):
    """
    Parameters:
     - dev
     - pipe
     - ppg
    """
    self.send_tm_get_ppg_drop(dev, pipe, ppg)
    return self.recv_tm_get_ppg_drop()

  def send_tm_get_ppg_drop(self, dev, pipe, ppg):
    self._oprot.writeMessageBegin('tm_get_ppg_drop', TMessageType.CALL, self._seqid)
    args = tm_get_ppg_drop_args()
    args.dev = dev
    args.pipe = pipe
    args.ppg = ppg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_ppg_drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_ppg_drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_ppg_drop failed: unknown result");

  def tm_get_q_drop(self, dev, pipe, port, q):
    """
    Parameters:
     - dev
     - pipe
     - port
     - q
    """
    self.send_tm_get_q_drop(dev, pipe, port, q)
    return self.recv_tm_get_q_drop()

  def send_tm_get_q_drop(self, dev, pipe, port, q):
    self._oprot.writeMessageBegin('tm_get_q_drop', TMessageType.CALL, self._seqid)
    args = tm_get_q_drop_args()
    args.dev = dev
    args.pipe = pipe
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_drop(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_drop_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_drop failed: unknown result");

  def tm_get_ppg_usage(self, dev, pipe, ppg):
    """
    Parameters:
     - dev
     - pipe
     - ppg
    """
    self.send_tm_get_ppg_usage(dev, pipe, ppg)
    return self.recv_tm_get_ppg_usage()

  def send_tm_get_ppg_usage(self, dev, pipe, ppg):
    self._oprot.writeMessageBegin('tm_get_ppg_usage', TMessageType.CALL, self._seqid)
    args = tm_get_ppg_usage_args()
    args.dev = dev
    args.pipe = pipe
    args.ppg = ppg
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_ppg_usage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_ppg_usage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_ppg_usage failed: unknown result");

  def tm_get_q_usage(self, dev, pipe, port, q):
    """
    Parameters:
     - dev
     - pipe
     - port
     - q
    """
    self.send_tm_get_q_usage(dev, pipe, port, q)
    return self.recv_tm_get_q_usage()

  def send_tm_get_q_usage(self, dev, pipe, port, q):
    self._oprot.writeMessageBegin('tm_get_q_usage', TMessageType.CALL, self._seqid)
    args = tm_get_q_usage_args()
    args.dev = dev
    args.pipe = pipe
    args.port = port
    args.q = q
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_q_usage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_q_usage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_q_usage failed: unknown result");

  def tm_get_pool_usage(self, dev, pool):
    """
    Parameters:
     - dev
     - pool
    """
    self.send_tm_get_pool_usage(dev, pool)
    return self.recv_tm_get_pool_usage()

  def send_tm_get_pool_usage(self, dev, pool):
    self._oprot.writeMessageBegin('tm_get_pool_usage', TMessageType.CALL, self._seqid)
    args = tm_get_pool_usage_args()
    args.dev = dev
    args.pool = pool
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_get_pool_usage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_get_pool_usage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "tm_get_pool_usage failed: unknown result");

  def tm_set_ut_mode_as_model(self, dev):
    """
    Parameters:
     - dev
    """
    self.send_tm_set_ut_mode_as_model(dev)
    self.recv_tm_set_ut_mode_as_model()

  def send_tm_set_ut_mode_as_model(self, dev):
    self._oprot.writeMessageBegin('tm_set_ut_mode_as_model', TMessageType.CALL, self._seqid)
    args = tm_set_ut_mode_as_model_args()
    args.dev = dev
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_ut_mode_as_model(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_ut_mode_as_model_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def tm_set_ut_mode_as_asic(self, dev):
    """
    Parameters:
     - dev
    """
    self.send_tm_set_ut_mode_as_asic(dev)
    self.recv_tm_set_ut_mode_as_asic()

  def send_tm_set_ut_mode_as_asic(self, dev):
    self._oprot.writeMessageBegin('tm_set_ut_mode_as_asic', TMessageType.CALL, self._seqid)
    args = tm_set_ut_mode_as_asic_args()
    args.dev = dev
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_tm_set_ut_mode_as_asic(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = tm_set_ut_mode_as_asic_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["tm_allocate_ppg"] = Processor.process_tm_allocate_ppg
    self._processMap["tm_free_ppg"] = Processor.process_tm_free_ppg
    self._processMap["tm_get_default_ppg"] = Processor.process_tm_get_default_ppg
    self._processMap["tm_set_ppg_icos_mapping"] = Processor.process_tm_set_ppg_icos_mapping
    self._processMap["tm_enable_lossless_treatment"] = Processor.process_tm_enable_lossless_treatment
    self._processMap["tm_disable_lossless_treatment"] = Processor.process_tm_disable_lossless_treatment
    self._processMap["tm_set_ppg_app_pool_usage"] = Processor.process_tm_set_ppg_app_pool_usage
    self._processMap["tm_disable_ppg_app_pool_usage"] = Processor.process_tm_disable_ppg_app_pool_usage
    self._processMap["tm_set_ppg_guaranteed_min_limit"] = Processor.process_tm_set_ppg_guaranteed_min_limit
    self._processMap["tm_set_ppg_skid_limit"] = Processor.process_tm_set_ppg_skid_limit
    self._processMap["tm_set_guaranteed_min_skid_hysteresis"] = Processor.process_tm_set_guaranteed_min_skid_hysteresis
    self._processMap["tm_set_port_q_mapping"] = Processor.process_tm_set_port_q_mapping
    self._processMap["tm_set_q_app_pool_usage"] = Processor.process_tm_set_q_app_pool_usage
    self._processMap["tm_disable_q_app_pool_usage"] = Processor.process_tm_disable_q_app_pool_usage
    self._processMap["tm_set_q_guaranteed_min_limit"] = Processor.process_tm_set_q_guaranteed_min_limit
    self._processMap["tm_set_q_color_limit"] = Processor.process_tm_set_q_color_limit
    self._processMap["tm_set_q_color_hysteresis"] = Processor.process_tm_set_q_color_hysteresis
    self._processMap["tm_enable_q_tail_drop"] = Processor.process_tm_enable_q_tail_drop
    self._processMap["tm_disable_q_tail_drop"] = Processor.process_tm_disable_q_tail_drop
    self._processMap["tm_enable_q_color_drop"] = Processor.process_tm_enable_q_color_drop
    self._processMap["tm_disable_q_color_drop"] = Processor.process_tm_disable_q_color_drop
    self._processMap["tm_set_negative_mirror_dest"] = Processor.process_tm_set_negative_mirror_dest
    self._processMap["tm_set_q_pfc_cos_mapping"] = Processor.process_tm_set_q_pfc_cos_mapping
    self._processMap["tm_set_app_pool_size"] = Processor.process_tm_set_app_pool_size
    self._processMap["tm_enable_app_pool_color_drop"] = Processor.process_tm_enable_app_pool_color_drop
    self._processMap["tm_disable_app_pool_color_drop"] = Processor.process_tm_disable_app_pool_color_drop
    self._processMap["tm_set_app_pool_color_drop_limit"] = Processor.process_tm_set_app_pool_color_drop_limit
    self._processMap["tm_set_app_pool_color_drop_hysteresis"] = Processor.process_tm_set_app_pool_color_drop_hysteresis
    self._processMap["tm_set_app_pool_pfc_limit"] = Processor.process_tm_set_app_pool_pfc_limit
    self._processMap["tm_set_skid_pool_size"] = Processor.process_tm_set_skid_pool_size
    self._processMap["tm_set_skid_pool_hysteresis"] = Processor.process_tm_set_skid_pool_hysteresis
    self._processMap["tm_set_negative_mirror_pool_size"] = Processor.process_tm_set_negative_mirror_pool_size
    self._processMap["tm_set_uc_cut_through_pool_size"] = Processor.process_tm_set_uc_cut_through_pool_size
    self._processMap["tm_set_mc_cut_through_pool_size"] = Processor.process_tm_set_mc_cut_through_pool_size
    self._processMap["tm_set_egress_pipe_limit"] = Processor.process_tm_set_egress_pipe_limit
    self._processMap["tm_set_egress_pipe_hysteresis"] = Processor.process_tm_set_egress_pipe_hysteresis
    self._processMap["tm_set_ingress_port_drop_limit"] = Processor.process_tm_set_ingress_port_drop_limit
    self._processMap["tm_set_ingress_port_hysteresis"] = Processor.process_tm_set_ingress_port_hysteresis
    self._processMap["tm_set_port_uc_cut_through_limit"] = Processor.process_tm_set_port_uc_cut_through_limit
    self._processMap["tm_set_port_flowcontrol_mode"] = Processor.process_tm_set_port_flowcontrol_mode
    self._processMap["tm_set_port_pfc_cos_mapping"] = Processor.process_tm_set_port_pfc_cos_mapping
    self._processMap["tm_set_cpuport"] = Processor.process_tm_set_cpuport
    self._processMap["tm_reset_cpuport"] = Processor.process_tm_reset_cpuport
    self._processMap["tm_set_q_sched_priority"] = Processor.process_tm_set_q_sched_priority
    self._processMap["tm_set_q_dwrr_weight"] = Processor.process_tm_set_q_dwrr_weight
    self._processMap["tm_set_q_shaping_rate"] = Processor.process_tm_set_q_shaping_rate
    self._processMap["tm_set_q_guaranteed_rate"] = Processor.process_tm_set_q_guaranteed_rate
    self._processMap["tm_set_q_remaining_bw_sched_priority"] = Processor.process_tm_set_q_remaining_bw_sched_priority
    self._processMap["tm_sched_q_l1_set"] = Processor.process_tm_sched_q_l1_set
    self._processMap["tm_sched_q_l1_reset"] = Processor.process_tm_sched_q_l1_reset
    self._processMap["tm_sched_l1_priority_set"] = Processor.process_tm_sched_l1_priority_set
    self._processMap["tm_sched_l1_dwrr_weight_set"] = Processor.process_tm_sched_l1_dwrr_weight_set
    self._processMap["tm_sched_l1_shaping_rate_set"] = Processor.process_tm_sched_l1_shaping_rate_set
    self._processMap["tm_sched_l1_max_shaping_rate_enable"] = Processor.process_tm_sched_l1_max_shaping_rate_enable
    self._processMap["tm_sched_l1_max_shaping_rate_disable"] = Processor.process_tm_sched_l1_max_shaping_rate_disable
    self._processMap["tm_sched_l1_priority_prop_enable"] = Processor.process_tm_sched_l1_priority_prop_enable
    self._processMap["tm_sched_l1_priority_prop_disable"] = Processor.process_tm_sched_l1_priority_prop_disable
    self._processMap["tm_sched_l1_guaranteed_rate_set"] = Processor.process_tm_sched_l1_guaranteed_rate_set
    self._processMap["tm_sched_l1_remaining_bw_priority_set"] = Processor.process_tm_sched_l1_remaining_bw_priority_set
    self._processMap["tm_sched_l1_guaranteed_rate_enable"] = Processor.process_tm_sched_l1_guaranteed_rate_enable
    self._processMap["tm_sched_l1_guaranteed_rate_disable"] = Processor.process_tm_sched_l1_guaranteed_rate_disable
    self._processMap["tm_sched_l1_enable"] = Processor.process_tm_sched_l1_enable
    self._processMap["tm_sched_l1_disable"] = Processor.process_tm_sched_l1_disable
    self._processMap["tm_sched_l1_free"] = Processor.process_tm_sched_l1_free
    self._processMap["tm_set_port_shaping_rate"] = Processor.process_tm_set_port_shaping_rate
    self._processMap["tm_set_shaper_pkt_ifg_compensation"] = Processor.process_tm_set_shaper_pkt_ifg_compensation
    self._processMap["tm_enable_q_sched"] = Processor.process_tm_enable_q_sched
    self._processMap["tm_disable_q_sched"] = Processor.process_tm_disable_q_sched
    self._processMap["tm_enable_port_shaping"] = Processor.process_tm_enable_port_shaping
    self._processMap["tm_disable_port_shaping"] = Processor.process_tm_disable_port_shaping
    self._processMap["tm_enable_port_sched"] = Processor.process_tm_enable_port_sched
    self._processMap["tm_disable_port_sched"] = Processor.process_tm_disable_port_sched
    self._processMap["tm_enable_q_max_shaping_rate"] = Processor.process_tm_enable_q_max_shaping_rate
    self._processMap["tm_disable_q_max_shaping_rate"] = Processor.process_tm_disable_q_max_shaping_rate
    self._processMap["tm_enable_q_min_shaping_rate"] = Processor.process_tm_enable_q_min_shaping_rate
    self._processMap["tm_disable_q_min_shaping_rate"] = Processor.process_tm_disable_q_min_shaping_rate
    self._processMap["tm_complete_operations"] = Processor.process_tm_complete_operations
    self._processMap["tm_set_timestamp_shift"] = Processor.process_tm_set_timestamp_shift
    self._processMap["tm_get_q_sched_priority"] = Processor.process_tm_get_q_sched_priority
    self._processMap["tm_get_q_dwrr_weight"] = Processor.process_tm_get_q_dwrr_weight
    self._processMap["tm_get_q_shaping_rate"] = Processor.process_tm_get_q_shaping_rate
    self._processMap["tm_get_q_guaranteed_rate"] = Processor.process_tm_get_q_guaranteed_rate
    self._processMap["tm_get_q_remaining_bw_sched_priority"] = Processor.process_tm_get_q_remaining_bw_sched_priority
    self._processMap["tm_get_port_shaping_rate"] = Processor.process_tm_get_port_shaping_rate
    self._processMap["tm_get_shaper_pkt_ifg_compensation"] = Processor.process_tm_get_shaper_pkt_ifg_compensation
    self._processMap["tm_get_egress_pipe_limit"] = Processor.process_tm_get_egress_pipe_limit
    self._processMap["tm_get_egress_pipe_hysteresis"] = Processor.process_tm_get_egress_pipe_hysteresis
    self._processMap["tm_get_port_q_mapping"] = Processor.process_tm_get_port_q_mapping
    self._processMap["tm_get_q_app_pool_usage"] = Processor.process_tm_get_q_app_pool_usage
    self._processMap["tm_get_q_guaranteed_min_limit"] = Processor.process_tm_get_q_guaranteed_min_limit
    self._processMap["tm_get_q_color_limit"] = Processor.process_tm_get_q_color_limit
    self._processMap["tm_get_q_color_hysteresis"] = Processor.process_tm_get_q_color_hysteresis
    self._processMap["tm_get_port_uc_cut_through_limit"] = Processor.process_tm_get_port_uc_cut_through_limit
    self._processMap["tm_get_total_ppg"] = Processor.process_tm_get_total_ppg
    self._processMap["tm_get_unused_ppg_count"] = Processor.process_tm_get_unused_ppg_count
    self._processMap["tm_get_ppg_app_pool_usage"] = Processor.process_tm_get_ppg_app_pool_usage
    self._processMap["tm_get_ppg_guaranteed_min_limit"] = Processor.process_tm_get_ppg_guaranteed_min_limit
    self._processMap["tm_get_ppg_skid_limit"] = Processor.process_tm_get_ppg_skid_limit
    self._processMap["tm_get_ppg_guaranteed_min_skid_hysteresis"] = Processor.process_tm_get_ppg_guaranteed_min_skid_hysteresis
    self._processMap["tm_get_app_pool_size"] = Processor.process_tm_get_app_pool_size
    self._processMap["tm_get_app_pool_color_drop_limit"] = Processor.process_tm_get_app_pool_color_drop_limit
    self._processMap["tm_get_app_pool_color_drop_hysteresis"] = Processor.process_tm_get_app_pool_color_drop_hysteresis
    self._processMap["tm_get_app_pool_pfc_limit"] = Processor.process_tm_get_app_pool_pfc_limit
    self._processMap["tm_get_skid_pool_size"] = Processor.process_tm_get_skid_pool_size
    self._processMap["tm_get_skid_pool_hysteresis"] = Processor.process_tm_get_skid_pool_hysteresis
    self._processMap["tm_get_negative_mirror_pool_size"] = Processor.process_tm_get_negative_mirror_pool_size
    self._processMap["tm_get_uc_cut_through_pool_size"] = Processor.process_tm_get_uc_cut_through_pool_size
    self._processMap["tm_get_mc_cut_through_pool_size"] = Processor.process_tm_get_mc_cut_through_pool_size
    self._processMap["tm_get_ingress_port_drop_limit"] = Processor.process_tm_get_ingress_port_drop_limit
    self._processMap["tm_get_ingress_port_hysteresis"] = Processor.process_tm_get_ingress_port_hysteresis
    self._processMap["tm_get_port_flowcontrol_mode"] = Processor.process_tm_get_port_flowcontrol_mode
    self._processMap["tm_get_port_pfc_cos_mapping"] = Processor.process_tm_get_port_pfc_cos_mapping
    self._processMap["tm_get_ppg_icos_mapping"] = Processor.process_tm_get_ppg_icos_mapping
    self._processMap["tm_get_timestamp_shift"] = Processor.process_tm_get_timestamp_shift
    self._processMap["tm_get_ppg_drop"] = Processor.process_tm_get_ppg_drop
    self._processMap["tm_get_q_drop"] = Processor.process_tm_get_q_drop
    self._processMap["tm_get_ppg_usage"] = Processor.process_tm_get_ppg_usage
    self._processMap["tm_get_q_usage"] = Processor.process_tm_get_q_usage
    self._processMap["tm_get_pool_usage"] = Processor.process_tm_get_pool_usage
    self._processMap["tm_set_ut_mode_as_model"] = Processor.process_tm_set_ut_mode_as_model
    self._processMap["tm_set_ut_mode_as_asic"] = Processor.process_tm_set_ut_mode_as_asic

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_tm_allocate_ppg(self, seqid, iprot, oprot):
    args = tm_allocate_ppg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_allocate_ppg_result()
    try:
      result.success = self._handler.tm_allocate_ppg(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_allocate_ppg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_free_ppg(self, seqid, iprot, oprot):
    args = tm_free_ppg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_free_ppg_result()
    try:
      self._handler.tm_free_ppg(args.dev, args.ppg)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_free_ppg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_default_ppg(self, seqid, iprot, oprot):
    args = tm_get_default_ppg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_default_ppg_result()
    try:
      result.success = self._handler.tm_get_default_ppg(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_default_ppg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_ppg_icos_mapping(self, seqid, iprot, oprot):
    args = tm_set_ppg_icos_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_ppg_icos_mapping_result()
    try:
      self._handler.tm_set_ppg_icos_mapping(args.dev, args.ppg, args.icos_map)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_ppg_icos_mapping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_enable_lossless_treatment(self, seqid, iprot, oprot):
    args = tm_enable_lossless_treatment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_enable_lossless_treatment_result()
    try:
      self._handler.tm_enable_lossless_treatment(args.dev, args.ppg)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_enable_lossless_treatment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_lossless_treatment(self, seqid, iprot, oprot):
    args = tm_disable_lossless_treatment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_lossless_treatment_result()
    try:
      self._handler.tm_disable_lossless_treatment(args.dev, args.ppg)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_lossless_treatment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_ppg_app_pool_usage(self, seqid, iprot, oprot):
    args = tm_set_ppg_app_pool_usage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_ppg_app_pool_usage_result()
    try:
      self._handler.tm_set_ppg_app_pool_usage(args.dev, args.ppg, args.pool, args.base_use_limit, args.dynamic_baf, args.hysteresis)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_ppg_app_pool_usage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_ppg_app_pool_usage(self, seqid, iprot, oprot):
    args = tm_disable_ppg_app_pool_usage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_ppg_app_pool_usage_result()
    try:
      self._handler.tm_disable_ppg_app_pool_usage(args.dev, args.pool, args.ppg)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_ppg_app_pool_usage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_ppg_guaranteed_min_limit(self, seqid, iprot, oprot):
    args = tm_set_ppg_guaranteed_min_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_ppg_guaranteed_min_limit_result()
    try:
      self._handler.tm_set_ppg_guaranteed_min_limit(args.dev, args.ppg, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_ppg_guaranteed_min_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_ppg_skid_limit(self, seqid, iprot, oprot):
    args = tm_set_ppg_skid_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_ppg_skid_limit_result()
    try:
      self._handler.tm_set_ppg_skid_limit(args.dev, args.ppg, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_ppg_skid_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_guaranteed_min_skid_hysteresis(self, seqid, iprot, oprot):
    args = tm_set_guaranteed_min_skid_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_guaranteed_min_skid_hysteresis_result()
    try:
      self._handler.tm_set_guaranteed_min_skid_hysteresis(args.dev, args.ppg, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_guaranteed_min_skid_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_port_q_mapping(self, seqid, iprot, oprot):
    args = tm_set_port_q_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_port_q_mapping_result()
    try:
      self._handler.tm_set_port_q_mapping(args.dev, args.port, args.q_count, args.q_map)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_port_q_mapping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_q_app_pool_usage(self, seqid, iprot, oprot):
    args = tm_set_q_app_pool_usage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_q_app_pool_usage_result()
    try:
      self._handler.tm_set_q_app_pool_usage(args.dev, args.port, args.q, args.pool, args.base_use_limit, args.dynamic_baf, args.hysteresis)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_q_app_pool_usage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_q_app_pool_usage(self, seqid, iprot, oprot):
    args = tm_disable_q_app_pool_usage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_q_app_pool_usage_result()
    try:
      self._handler.tm_disable_q_app_pool_usage(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_q_app_pool_usage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_q_guaranteed_min_limit(self, seqid, iprot, oprot):
    args = tm_set_q_guaranteed_min_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_q_guaranteed_min_limit_result()
    try:
      self._handler.tm_set_q_guaranteed_min_limit(args.dev, args.port, args.q, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_q_guaranteed_min_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_q_color_limit(self, seqid, iprot, oprot):
    args = tm_set_q_color_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_q_color_limit_result()
    try:
      self._handler.tm_set_q_color_limit(args.dev, args.port, args.q, args.color, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_q_color_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_q_color_hysteresis(self, seqid, iprot, oprot):
    args = tm_set_q_color_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_q_color_hysteresis_result()
    try:
      self._handler.tm_set_q_color_hysteresis(args.dev, args.port, args.q, args.color, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_q_color_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_enable_q_tail_drop(self, seqid, iprot, oprot):
    args = tm_enable_q_tail_drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_enable_q_tail_drop_result()
    try:
      self._handler.tm_enable_q_tail_drop(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_enable_q_tail_drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_q_tail_drop(self, seqid, iprot, oprot):
    args = tm_disable_q_tail_drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_q_tail_drop_result()
    try:
      self._handler.tm_disable_q_tail_drop(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_q_tail_drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_enable_q_color_drop(self, seqid, iprot, oprot):
    args = tm_enable_q_color_drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_enable_q_color_drop_result()
    try:
      self._handler.tm_enable_q_color_drop(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_enable_q_color_drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_q_color_drop(self, seqid, iprot, oprot):
    args = tm_disable_q_color_drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_q_color_drop_result()
    try:
      self._handler.tm_disable_q_color_drop(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_q_color_drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_negative_mirror_dest(self, seqid, iprot, oprot):
    args = tm_set_negative_mirror_dest_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_negative_mirror_dest_result()
    try:
      self._handler.tm_set_negative_mirror_dest(args.dev, args.pipe, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_negative_mirror_dest", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_q_pfc_cos_mapping(self, seqid, iprot, oprot):
    args = tm_set_q_pfc_cos_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_q_pfc_cos_mapping_result()
    try:
      self._handler.tm_set_q_pfc_cos_mapping(args.dev, args.port, args.q, args.cos)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_q_pfc_cos_mapping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_app_pool_size(self, seqid, iprot, oprot):
    args = tm_set_app_pool_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_app_pool_size_result()
    try:
      self._handler.tm_set_app_pool_size(args.dev, args.pool, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_app_pool_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_enable_app_pool_color_drop(self, seqid, iprot, oprot):
    args = tm_enable_app_pool_color_drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_enable_app_pool_color_drop_result()
    try:
      self._handler.tm_enable_app_pool_color_drop(args.dev, args.pool)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_enable_app_pool_color_drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_app_pool_color_drop(self, seqid, iprot, oprot):
    args = tm_disable_app_pool_color_drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_app_pool_color_drop_result()
    try:
      self._handler.tm_disable_app_pool_color_drop(args.dev, args.pool)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_app_pool_color_drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_app_pool_color_drop_limit(self, seqid, iprot, oprot):
    args = tm_set_app_pool_color_drop_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_app_pool_color_drop_limit_result()
    try:
      self._handler.tm_set_app_pool_color_drop_limit(args.dev, args.pool, args.color, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_app_pool_color_drop_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_app_pool_color_drop_hysteresis(self, seqid, iprot, oprot):
    args = tm_set_app_pool_color_drop_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_app_pool_color_drop_hysteresis_result()
    try:
      self._handler.tm_set_app_pool_color_drop_hysteresis(args.dev, args.color, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_app_pool_color_drop_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_app_pool_pfc_limit(self, seqid, iprot, oprot):
    args = tm_set_app_pool_pfc_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_app_pool_pfc_limit_result()
    try:
      self._handler.tm_set_app_pool_pfc_limit(args.dev, args.pool, args.icos, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_app_pool_pfc_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_skid_pool_size(self, seqid, iprot, oprot):
    args = tm_set_skid_pool_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_skid_pool_size_result()
    try:
      self._handler.tm_set_skid_pool_size(args.dev, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_skid_pool_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_skid_pool_hysteresis(self, seqid, iprot, oprot):
    args = tm_set_skid_pool_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_skid_pool_hysteresis_result()
    try:
      self._handler.tm_set_skid_pool_hysteresis(args.dev, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_skid_pool_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_negative_mirror_pool_size(self, seqid, iprot, oprot):
    args = tm_set_negative_mirror_pool_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_negative_mirror_pool_size_result()
    try:
      self._handler.tm_set_negative_mirror_pool_size(args.dev, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_negative_mirror_pool_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_uc_cut_through_pool_size(self, seqid, iprot, oprot):
    args = tm_set_uc_cut_through_pool_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_uc_cut_through_pool_size_result()
    try:
      self._handler.tm_set_uc_cut_through_pool_size(args.dev, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_uc_cut_through_pool_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_mc_cut_through_pool_size(self, seqid, iprot, oprot):
    args = tm_set_mc_cut_through_pool_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_mc_cut_through_pool_size_result()
    try:
      self._handler.tm_set_mc_cut_through_pool_size(args.dev, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_mc_cut_through_pool_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_egress_pipe_limit(self, seqid, iprot, oprot):
    args = tm_set_egress_pipe_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_egress_pipe_limit_result()
    try:
      self._handler.tm_set_egress_pipe_limit(args.dev, args.pipe, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_egress_pipe_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_egress_pipe_hysteresis(self, seqid, iprot, oprot):
    args = tm_set_egress_pipe_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_egress_pipe_hysteresis_result()
    try:
      self._handler.tm_set_egress_pipe_hysteresis(args.dev, args.pipe, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_egress_pipe_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_ingress_port_drop_limit(self, seqid, iprot, oprot):
    args = tm_set_ingress_port_drop_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_ingress_port_drop_limit_result()
    try:
      self._handler.tm_set_ingress_port_drop_limit(args.dev, args.port, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_ingress_port_drop_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_ingress_port_hysteresis(self, seqid, iprot, oprot):
    args = tm_set_ingress_port_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_ingress_port_hysteresis_result()
    try:
      self._handler.tm_set_ingress_port_hysteresis(args.dev, args.port, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_ingress_port_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_port_uc_cut_through_limit(self, seqid, iprot, oprot):
    args = tm_set_port_uc_cut_through_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_port_uc_cut_through_limit_result()
    try:
      self._handler.tm_set_port_uc_cut_through_limit(args.dev, args.port, args.cells)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_port_uc_cut_through_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_port_flowcontrol_mode(self, seqid, iprot, oprot):
    args = tm_set_port_flowcontrol_mode_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_port_flowcontrol_mode_result()
    try:
      self._handler.tm_set_port_flowcontrol_mode(args.dev, args.port, args.fctype)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_port_flowcontrol_mode", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_port_pfc_cos_mapping(self, seqid, iprot, oprot):
    args = tm_set_port_pfc_cos_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_port_pfc_cos_mapping_result()
    try:
      self._handler.tm_set_port_pfc_cos_mapping(args.dev, args.port, args.cos_icos_map)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_port_pfc_cos_mapping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_cpuport(self, seqid, iprot, oprot):
    args = tm_set_cpuport_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_cpuport_result()
    try:
      self._handler.tm_set_cpuport(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_cpuport", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_reset_cpuport(self, seqid, iprot, oprot):
    args = tm_reset_cpuport_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_reset_cpuport_result()
    try:
      self._handler.tm_reset_cpuport(args.dev)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_reset_cpuport", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_q_sched_priority(self, seqid, iprot, oprot):
    args = tm_set_q_sched_priority_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_q_sched_priority_result()
    try:
      self._handler.tm_set_q_sched_priority(args.dev, args.port, args.q, args.prio)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_q_sched_priority", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_q_dwrr_weight(self, seqid, iprot, oprot):
    args = tm_set_q_dwrr_weight_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_q_dwrr_weight_result()
    try:
      self._handler.tm_set_q_dwrr_weight(args.dev, args.port, args.q, args.weight)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_q_dwrr_weight", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_q_shaping_rate(self, seqid, iprot, oprot):
    args = tm_set_q_shaping_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_q_shaping_rate_result()
    try:
      self._handler.tm_set_q_shaping_rate(args.dev, args.port, args.q, args.pps, args.burstsize, args.rate)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_q_shaping_rate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_q_guaranteed_rate(self, seqid, iprot, oprot):
    args = tm_set_q_guaranteed_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_q_guaranteed_rate_result()
    try:
      self._handler.tm_set_q_guaranteed_rate(args.dev, args.port, args.q, args.pps, args.burstsize, args.rate)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_q_guaranteed_rate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_q_remaining_bw_sched_priority(self, seqid, iprot, oprot):
    args = tm_set_q_remaining_bw_sched_priority_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_q_remaining_bw_sched_priority_result()
    try:
      self._handler.tm_set_q_remaining_bw_sched_priority(args.dev, args.port, args.q, args.prio)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_q_remaining_bw_sched_priority", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_q_l1_set(self, seqid, iprot, oprot):
    args = tm_sched_q_l1_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_q_l1_set_result()
    try:
      self._handler.tm_sched_q_l1_set(args.dev, args.port, args.l1_node, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_q_l1_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_q_l1_reset(self, seqid, iprot, oprot):
    args = tm_sched_q_l1_reset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_q_l1_reset_result()
    try:
      self._handler.tm_sched_q_l1_reset(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_q_l1_reset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_priority_set(self, seqid, iprot, oprot):
    args = tm_sched_l1_priority_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_priority_set_result()
    try:
      self._handler.tm_sched_l1_priority_set(args.dev, args.port, args.l1_node, args.priority)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_priority_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_dwrr_weight_set(self, seqid, iprot, oprot):
    args = tm_sched_l1_dwrr_weight_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_dwrr_weight_set_result()
    try:
      self._handler.tm_sched_l1_dwrr_weight_set(args.dev, args.port, args.l1_node, args.weight)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_dwrr_weight_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_shaping_rate_set(self, seqid, iprot, oprot):
    args = tm_sched_l1_shaping_rate_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_shaping_rate_set_result()
    try:
      self._handler.tm_sched_l1_shaping_rate_set(args.dev, args.port, args.l1_node, args.pps, args.burst_size, args.rate)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_shaping_rate_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_max_shaping_rate_enable(self, seqid, iprot, oprot):
    args = tm_sched_l1_max_shaping_rate_enable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_max_shaping_rate_enable_result()
    try:
      self._handler.tm_sched_l1_max_shaping_rate_enable(args.dev, args.port, args.l1_node)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_max_shaping_rate_enable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_max_shaping_rate_disable(self, seqid, iprot, oprot):
    args = tm_sched_l1_max_shaping_rate_disable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_max_shaping_rate_disable_result()
    try:
      self._handler.tm_sched_l1_max_shaping_rate_disable(args.dev, args.port, args.l1_node)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_max_shaping_rate_disable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_priority_prop_enable(self, seqid, iprot, oprot):
    args = tm_sched_l1_priority_prop_enable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_priority_prop_enable_result()
    try:
      self._handler.tm_sched_l1_priority_prop_enable(args.dev, args.port, args.l1_node)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_priority_prop_enable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_priority_prop_disable(self, seqid, iprot, oprot):
    args = tm_sched_l1_priority_prop_disable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_priority_prop_disable_result()
    try:
      self._handler.tm_sched_l1_priority_prop_disable(args.dev, args.port, args.l1_node)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_priority_prop_disable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_guaranteed_rate_set(self, seqid, iprot, oprot):
    args = tm_sched_l1_guaranteed_rate_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_guaranteed_rate_set_result()
    try:
      self._handler.tm_sched_l1_guaranteed_rate_set(args.dev, args.port, args.l1_node, args.pps, args.burst_size, args.rate)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_guaranteed_rate_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_remaining_bw_priority_set(self, seqid, iprot, oprot):
    args = tm_sched_l1_remaining_bw_priority_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_remaining_bw_priority_set_result()
    try:
      self._handler.tm_sched_l1_remaining_bw_priority_set(args.dev, args.port, args.l1_node, args.priority)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_remaining_bw_priority_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_guaranteed_rate_enable(self, seqid, iprot, oprot):
    args = tm_sched_l1_guaranteed_rate_enable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_guaranteed_rate_enable_result()
    try:
      self._handler.tm_sched_l1_guaranteed_rate_enable(args.dev, args.port, args.l1_node)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_guaranteed_rate_enable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_guaranteed_rate_disable(self, seqid, iprot, oprot):
    args = tm_sched_l1_guaranteed_rate_disable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_guaranteed_rate_disable_result()
    try:
      self._handler.tm_sched_l1_guaranteed_rate_disable(args.dev, args.port, args.l1_node)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_guaranteed_rate_disable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_enable(self, seqid, iprot, oprot):
    args = tm_sched_l1_enable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_enable_result()
    try:
      self._handler.tm_sched_l1_enable(args.dev, args.port, args.l1_node)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_enable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_disable(self, seqid, iprot, oprot):
    args = tm_sched_l1_disable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_disable_result()
    try:
      self._handler.tm_sched_l1_disable(args.dev, args.port, args.l1_node)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_disable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_sched_l1_free(self, seqid, iprot, oprot):
    args = tm_sched_l1_free_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_sched_l1_free_result()
    try:
      self._handler.tm_sched_l1_free(args.dev, args.port, args.l1_node)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_sched_l1_free", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_port_shaping_rate(self, seqid, iprot, oprot):
    args = tm_set_port_shaping_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_port_shaping_rate_result()
    try:
      self._handler.tm_set_port_shaping_rate(args.dev, args.port, args.pps, args.burstsize, args.rate)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_port_shaping_rate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_shaper_pkt_ifg_compensation(self, seqid, iprot, oprot):
    args = tm_set_shaper_pkt_ifg_compensation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_shaper_pkt_ifg_compensation_result()
    try:
      self._handler.tm_set_shaper_pkt_ifg_compensation(args.dev, args.pipe, args.adjustment)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_shaper_pkt_ifg_compensation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_enable_q_sched(self, seqid, iprot, oprot):
    args = tm_enable_q_sched_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_enable_q_sched_result()
    try:
      self._handler.tm_enable_q_sched(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_enable_q_sched", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_q_sched(self, seqid, iprot, oprot):
    args = tm_disable_q_sched_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_q_sched_result()
    try:
      self._handler.tm_disable_q_sched(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_q_sched", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_enable_port_shaping(self, seqid, iprot, oprot):
    args = tm_enable_port_shaping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_enable_port_shaping_result()
    try:
      self._handler.tm_enable_port_shaping(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_enable_port_shaping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_port_shaping(self, seqid, iprot, oprot):
    args = tm_disable_port_shaping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_port_shaping_result()
    try:
      self._handler.tm_disable_port_shaping(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_port_shaping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_enable_port_sched(self, seqid, iprot, oprot):
    args = tm_enable_port_sched_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_enable_port_sched_result()
    try:
      self._handler.tm_enable_port_sched(args.dev, args.port, args.speed)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_enable_port_sched", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_port_sched(self, seqid, iprot, oprot):
    args = tm_disable_port_sched_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_port_sched_result()
    try:
      self._handler.tm_disable_port_sched(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_port_sched", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_enable_q_max_shaping_rate(self, seqid, iprot, oprot):
    args = tm_enable_q_max_shaping_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_enable_q_max_shaping_rate_result()
    try:
      self._handler.tm_enable_q_max_shaping_rate(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_enable_q_max_shaping_rate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_q_max_shaping_rate(self, seqid, iprot, oprot):
    args = tm_disable_q_max_shaping_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_q_max_shaping_rate_result()
    try:
      self._handler.tm_disable_q_max_shaping_rate(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_q_max_shaping_rate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_enable_q_min_shaping_rate(self, seqid, iprot, oprot):
    args = tm_enable_q_min_shaping_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_enable_q_min_shaping_rate_result()
    try:
      self._handler.tm_enable_q_min_shaping_rate(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_enable_q_min_shaping_rate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_disable_q_min_shaping_rate(self, seqid, iprot, oprot):
    args = tm_disable_q_min_shaping_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_disable_q_min_shaping_rate_result()
    try:
      self._handler.tm_disable_q_min_shaping_rate(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_disable_q_min_shaping_rate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_complete_operations(self, seqid, iprot, oprot):
    args = tm_complete_operations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_complete_operations_result()
    try:
      self._handler.tm_complete_operations(args.dev)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_complete_operations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_timestamp_shift(self, seqid, iprot, oprot):
    args = tm_set_timestamp_shift_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_timestamp_shift_result()
    try:
      self._handler.tm_set_timestamp_shift(args.dev, args.shift)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_timestamp_shift", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_sched_priority(self, seqid, iprot, oprot):
    args = tm_get_q_sched_priority_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_sched_priority_result()
    try:
      result.success = self._handler.tm_get_q_sched_priority(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_sched_priority", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_dwrr_weight(self, seqid, iprot, oprot):
    args = tm_get_q_dwrr_weight_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_dwrr_weight_result()
    try:
      result.success = self._handler.tm_get_q_dwrr_weight(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_dwrr_weight", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_shaping_rate(self, seqid, iprot, oprot):
    args = tm_get_q_shaping_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_shaping_rate_result()
    try:
      result.success = self._handler.tm_get_q_shaping_rate(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_shaping_rate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_guaranteed_rate(self, seqid, iprot, oprot):
    args = tm_get_q_guaranteed_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_guaranteed_rate_result()
    try:
      result.success = self._handler.tm_get_q_guaranteed_rate(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_guaranteed_rate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_remaining_bw_sched_priority(self, seqid, iprot, oprot):
    args = tm_get_q_remaining_bw_sched_priority_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_remaining_bw_sched_priority_result()
    try:
      result.success = self._handler.tm_get_q_remaining_bw_sched_priority(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_remaining_bw_sched_priority", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_port_shaping_rate(self, seqid, iprot, oprot):
    args = tm_get_port_shaping_rate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_port_shaping_rate_result()
    try:
      result.success = self._handler.tm_get_port_shaping_rate(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_port_shaping_rate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_shaper_pkt_ifg_compensation(self, seqid, iprot, oprot):
    args = tm_get_shaper_pkt_ifg_compensation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_shaper_pkt_ifg_compensation_result()
    try:
      result.success = self._handler.tm_get_shaper_pkt_ifg_compensation(args.dev, args.pipe)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_shaper_pkt_ifg_compensation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_egress_pipe_limit(self, seqid, iprot, oprot):
    args = tm_get_egress_pipe_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_egress_pipe_limit_result()
    try:
      result.success = self._handler.tm_get_egress_pipe_limit(args.dev, args.pipe)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_egress_pipe_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_egress_pipe_hysteresis(self, seqid, iprot, oprot):
    args = tm_get_egress_pipe_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_egress_pipe_hysteresis_result()
    try:
      result.success = self._handler.tm_get_egress_pipe_hysteresis(args.dev, args.pipe)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_egress_pipe_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_port_q_mapping(self, seqid, iprot, oprot):
    args = tm_get_port_q_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_port_q_mapping_result()
    try:
      result.success = self._handler.tm_get_port_q_mapping(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_port_q_mapping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_app_pool_usage(self, seqid, iprot, oprot):
    args = tm_get_q_app_pool_usage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_app_pool_usage_result()
    try:
      result.success = self._handler.tm_get_q_app_pool_usage(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_app_pool_usage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_guaranteed_min_limit(self, seqid, iprot, oprot):
    args = tm_get_q_guaranteed_min_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_guaranteed_min_limit_result()
    try:
      result.success = self._handler.tm_get_q_guaranteed_min_limit(args.dev, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_guaranteed_min_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_color_limit(self, seqid, iprot, oprot):
    args = tm_get_q_color_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_color_limit_result()
    try:
      result.success = self._handler.tm_get_q_color_limit(args.dev, args.port, args.q, args.color)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_color_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_color_hysteresis(self, seqid, iprot, oprot):
    args = tm_get_q_color_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_color_hysteresis_result()
    try:
      result.success = self._handler.tm_get_q_color_hysteresis(args.dev, args.port, args.q, args.color)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_color_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_port_uc_cut_through_limit(self, seqid, iprot, oprot):
    args = tm_get_port_uc_cut_through_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_port_uc_cut_through_limit_result()
    try:
      result.success = self._handler.tm_get_port_uc_cut_through_limit(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_port_uc_cut_through_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_total_ppg(self, seqid, iprot, oprot):
    args = tm_get_total_ppg_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_total_ppg_result()
    try:
      result.success = self._handler.tm_get_total_ppg(args.dev, args.pipe)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_total_ppg", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_unused_ppg_count(self, seqid, iprot, oprot):
    args = tm_get_unused_ppg_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_unused_ppg_count_result()
    try:
      result.success = self._handler.tm_get_unused_ppg_count(args.dev, args.pipe)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_unused_ppg_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_ppg_app_pool_usage(self, seqid, iprot, oprot):
    args = tm_get_ppg_app_pool_usage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_ppg_app_pool_usage_result()
    try:
      result.success = self._handler.tm_get_ppg_app_pool_usage(args.dev, args.ppg, args.pool)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_ppg_app_pool_usage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_ppg_guaranteed_min_limit(self, seqid, iprot, oprot):
    args = tm_get_ppg_guaranteed_min_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_ppg_guaranteed_min_limit_result()
    try:
      result.success = self._handler.tm_get_ppg_guaranteed_min_limit(args.dev, args.ppg)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_ppg_guaranteed_min_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_ppg_skid_limit(self, seqid, iprot, oprot):
    args = tm_get_ppg_skid_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_ppg_skid_limit_result()
    try:
      result.success = self._handler.tm_get_ppg_skid_limit(args.dev, args.ppg)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_ppg_skid_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_ppg_guaranteed_min_skid_hysteresis(self, seqid, iprot, oprot):
    args = tm_get_ppg_guaranteed_min_skid_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_ppg_guaranteed_min_skid_hysteresis_result()
    try:
      result.success = self._handler.tm_get_ppg_guaranteed_min_skid_hysteresis(args.dev, args.ppg)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_ppg_guaranteed_min_skid_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_app_pool_size(self, seqid, iprot, oprot):
    args = tm_get_app_pool_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_app_pool_size_result()
    try:
      result.success = self._handler.tm_get_app_pool_size(args.dev, args.pool)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_app_pool_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_app_pool_color_drop_limit(self, seqid, iprot, oprot):
    args = tm_get_app_pool_color_drop_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_app_pool_color_drop_limit_result()
    try:
      result.success = self._handler.tm_get_app_pool_color_drop_limit(args.dev, args.pool, args.color)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_app_pool_color_drop_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_app_pool_color_drop_hysteresis(self, seqid, iprot, oprot):
    args = tm_get_app_pool_color_drop_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_app_pool_color_drop_hysteresis_result()
    try:
      result.success = self._handler.tm_get_app_pool_color_drop_hysteresis(args.dev, args.color)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_app_pool_color_drop_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_app_pool_pfc_limit(self, seqid, iprot, oprot):
    args = tm_get_app_pool_pfc_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_app_pool_pfc_limit_result()
    try:
      result.success = self._handler.tm_get_app_pool_pfc_limit(args.dev, args.pool, args.icos)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_app_pool_pfc_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_skid_pool_size(self, seqid, iprot, oprot):
    args = tm_get_skid_pool_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_skid_pool_size_result()
    try:
      result.success = self._handler.tm_get_skid_pool_size(args.dev)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_skid_pool_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_skid_pool_hysteresis(self, seqid, iprot, oprot):
    args = tm_get_skid_pool_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_skid_pool_hysteresis_result()
    try:
      result.success = self._handler.tm_get_skid_pool_hysteresis(args.dev)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_skid_pool_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_negative_mirror_pool_size(self, seqid, iprot, oprot):
    args = tm_get_negative_mirror_pool_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_negative_mirror_pool_size_result()
    try:
      result.success = self._handler.tm_get_negative_mirror_pool_size(args.dev)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_negative_mirror_pool_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_uc_cut_through_pool_size(self, seqid, iprot, oprot):
    args = tm_get_uc_cut_through_pool_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_uc_cut_through_pool_size_result()
    try:
      result.success = self._handler.tm_get_uc_cut_through_pool_size(args.dev, args.pool)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_uc_cut_through_pool_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_mc_cut_through_pool_size(self, seqid, iprot, oprot):
    args = tm_get_mc_cut_through_pool_size_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_mc_cut_through_pool_size_result()
    try:
      result.success = self._handler.tm_get_mc_cut_through_pool_size(args.dev, args.pool)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_mc_cut_through_pool_size", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_ingress_port_drop_limit(self, seqid, iprot, oprot):
    args = tm_get_ingress_port_drop_limit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_ingress_port_drop_limit_result()
    try:
      result.success = self._handler.tm_get_ingress_port_drop_limit(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_ingress_port_drop_limit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_ingress_port_hysteresis(self, seqid, iprot, oprot):
    args = tm_get_ingress_port_hysteresis_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_ingress_port_hysteresis_result()
    try:
      result.success = self._handler.tm_get_ingress_port_hysteresis(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_ingress_port_hysteresis", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_port_flowcontrol_mode(self, seqid, iprot, oprot):
    args = tm_get_port_flowcontrol_mode_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_port_flowcontrol_mode_result()
    try:
      result.success = self._handler.tm_get_port_flowcontrol_mode(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_port_flowcontrol_mode", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_port_pfc_cos_mapping(self, seqid, iprot, oprot):
    args = tm_get_port_pfc_cos_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_port_pfc_cos_mapping_result()
    try:
      result.success = self._handler.tm_get_port_pfc_cos_mapping(args.dev, args.port)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_port_pfc_cos_mapping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_ppg_icos_mapping(self, seqid, iprot, oprot):
    args = tm_get_ppg_icos_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_ppg_icos_mapping_result()
    try:
      result.success = self._handler.tm_get_ppg_icos_mapping(args.dev, args.ppg)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_ppg_icos_mapping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_timestamp_shift(self, seqid, iprot, oprot):
    args = tm_get_timestamp_shift_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_timestamp_shift_result()
    try:
      result.success = self._handler.tm_get_timestamp_shift(args.dev)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_timestamp_shift", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_ppg_drop(self, seqid, iprot, oprot):
    args = tm_get_ppg_drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_ppg_drop_result()
    try:
      result.success = self._handler.tm_get_ppg_drop(args.dev, args.pipe, args.ppg)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_ppg_drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_drop(self, seqid, iprot, oprot):
    args = tm_get_q_drop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_drop_result()
    try:
      result.success = self._handler.tm_get_q_drop(args.dev, args.pipe, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_drop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_ppg_usage(self, seqid, iprot, oprot):
    args = tm_get_ppg_usage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_ppg_usage_result()
    try:
      result.success = self._handler.tm_get_ppg_usage(args.dev, args.pipe, args.ppg)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_ppg_usage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_q_usage(self, seqid, iprot, oprot):
    args = tm_get_q_usage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_q_usage_result()
    try:
      result.success = self._handler.tm_get_q_usage(args.dev, args.pipe, args.port, args.q)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_q_usage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_get_pool_usage(self, seqid, iprot, oprot):
    args = tm_get_pool_usage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_get_pool_usage_result()
    try:
      result.success = self._handler.tm_get_pool_usage(args.dev, args.pool)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_get_pool_usage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_ut_mode_as_model(self, seqid, iprot, oprot):
    args = tm_set_ut_mode_as_model_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_ut_mode_as_model_result()
    try:
      self._handler.tm_set_ut_mode_as_model(args.dev)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_ut_mode_as_model", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_tm_set_ut_mode_as_asic(self, seqid, iprot, oprot):
    args = tm_set_ut_mode_as_asic_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tm_set_ut_mode_as_asic_result()
    try:
      self._handler.tm_set_ut_mode_as_asic(args.dev)
    except InvalidTmOperation as ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("tm_set_ut_mode_as_asic", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class tm_allocate_ppg_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_allocate_ppg_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_allocate_ppg_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_allocate_ppg_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_free_ppg_args:
  """
  Attributes:
   - dev
   - ppg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
  )

  def __init__(self, dev=None, ppg=None,):
    self.dev = dev
    self.ppg = ppg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_free_ppg_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_free_ppg_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_free_ppg_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_default_ppg_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_default_ppg_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_default_ppg_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_default_ppg_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ppg_icos_mapping_args:
  """
  Attributes:
   - dev
   - ppg
   - icos_map
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
    (3, TType.I16, 'icos_map', None, None, ), # 3
  )

  def __init__(self, dev=None, ppg=None, icos_map=None,):
    self.dev = dev
    self.ppg = ppg
    self.icos_map = icos_map

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.icos_map = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ppg_icos_mapping_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    if self.icos_map is not None:
      oprot.writeFieldBegin('icos_map', TType.I16, 3)
      oprot.writeI16(self.icos_map)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    value = (value * 31) ^ hash(self.icos_map)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ppg_icos_mapping_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ppg_icos_mapping_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_lossless_treatment_args:
  """
  Attributes:
   - dev
   - ppg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
  )

  def __init__(self, dev=None, ppg=None,):
    self.dev = dev
    self.ppg = ppg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_lossless_treatment_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_lossless_treatment_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_lossless_treatment_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_lossless_treatment_args:
  """
  Attributes:
   - dev
   - ppg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
  )

  def __init__(self, dev=None, ppg=None,):
    self.dev = dev
    self.ppg = ppg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_lossless_treatment_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_lossless_treatment_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_lossless_treatment_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ppg_app_pool_usage_args:
  """
  Attributes:
   - dev
   - ppg
   - pool
   - base_use_limit
   - dynamic_baf
   - hysteresis
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
    (3, TType.I32, 'pool', None, None, ), # 3
    (4, TType.I32, 'base_use_limit', None, None, ), # 4
    (5, TType.I32, 'dynamic_baf', None, None, ), # 5
    (6, TType.I32, 'hysteresis', None, None, ), # 6
  )

  def __init__(self, dev=None, ppg=None, pool=None, base_use_limit=None, dynamic_baf=None, hysteresis=None,):
    self.dev = dev
    self.ppg = ppg
    self.pool = pool
    self.base_use_limit = base_use_limit
    self.dynamic_baf = dynamic_baf
    self.hysteresis = hysteresis

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.base_use_limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.dynamic_baf = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.hysteresis = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ppg_app_pool_usage_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 3)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    if self.base_use_limit is not None:
      oprot.writeFieldBegin('base_use_limit', TType.I32, 4)
      oprot.writeI32(self.base_use_limit)
      oprot.writeFieldEnd()
    if self.dynamic_baf is not None:
      oprot.writeFieldBegin('dynamic_baf', TType.I32, 5)
      oprot.writeI32(self.dynamic_baf)
      oprot.writeFieldEnd()
    if self.hysteresis is not None:
      oprot.writeFieldBegin('hysteresis', TType.I32, 6)
      oprot.writeI32(self.hysteresis)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.base_use_limit)
    value = (value * 31) ^ hash(self.dynamic_baf)
    value = (value * 31) ^ hash(self.hysteresis)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ppg_app_pool_usage_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ppg_app_pool_usage_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_ppg_app_pool_usage_args:
  """
  Attributes:
   - dev
   - pool
   - ppg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
    (3, TType.I32, 'ppg', None, None, ), # 3
  )

  def __init__(self, dev=None, pool=None, ppg=None,):
    self.dev = dev
    self.pool = pool
    self.ppg = ppg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_ppg_app_pool_usage_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 3)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.ppg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_ppg_app_pool_usage_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_ppg_app_pool_usage_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ppg_guaranteed_min_limit_args:
  """
  Attributes:
   - dev
   - ppg
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
    (3, TType.I32, 'cells', None, None, ), # 3
  )

  def __init__(self, dev=None, ppg=None, cells=None,):
    self.dev = dev
    self.ppg = ppg
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ppg_guaranteed_min_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 3)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ppg_guaranteed_min_limit_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ppg_guaranteed_min_limit_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ppg_skid_limit_args:
  """
  Attributes:
   - dev
   - ppg
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
    (3, TType.I32, 'cells', None, None, ), # 3
  )

  def __init__(self, dev=None, ppg=None, cells=None,):
    self.dev = dev
    self.ppg = ppg
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ppg_skid_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 3)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ppg_skid_limit_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ppg_skid_limit_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_guaranteed_min_skid_hysteresis_args:
  """
  Attributes:
   - dev
   - ppg
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
    (3, TType.I32, 'cells', None, None, ), # 3
  )

  def __init__(self, dev=None, ppg=None, cells=None,):
    self.dev = dev
    self.ppg = ppg
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_guaranteed_min_skid_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 3)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_guaranteed_min_skid_hysteresis_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_guaranteed_min_skid_hysteresis_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_port_q_mapping_args:
  """
  Attributes:
   - dev
   - port
   - q_count
   - q_map
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I16, 'q_count', None, None, ), # 3
    (4, TType.STRUCT, 'q_map', (tm_q_map_t, tm_q_map_t.thrift_spec), None, ), # 4
  )

  def __init__(self, dev=None, port=None, q_count=None, q_map=None,):
    self.dev = dev
    self.port = port
    self.q_count = q_count
    self.q_map = q_map

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.q_count = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.q_map = tm_q_map_t()
          self.q_map.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_port_q_mapping_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q_count is not None:
      oprot.writeFieldBegin('q_count', TType.I16, 3)
      oprot.writeI16(self.q_count)
      oprot.writeFieldEnd()
    if self.q_map is not None:
      oprot.writeFieldBegin('q_map', TType.STRUCT, 4)
      self.q_map.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q_count)
    value = (value * 31) ^ hash(self.q_map)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_port_q_mapping_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_port_q_mapping_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_app_pool_usage_args:
  """
  Attributes:
   - dev
   - port
   - q
   - pool
   - base_use_limit
   - dynamic_baf
   - hysteresis
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.I32, 'pool', None, None, ), # 4
    (5, TType.I32, 'base_use_limit', None, None, ), # 5
    (6, TType.I32, 'dynamic_baf', None, None, ), # 6
    (7, TType.I32, 'hysteresis', None, None, ), # 7
  )

  def __init__(self, dev=None, port=None, q=None, pool=None, base_use_limit=None, dynamic_baf=None, hysteresis=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.pool = pool
    self.base_use_limit = base_use_limit
    self.dynamic_baf = dynamic_baf
    self.hysteresis = hysteresis

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.base_use_limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.dynamic_baf = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.hysteresis = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_app_pool_usage_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 4)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    if self.base_use_limit is not None:
      oprot.writeFieldBegin('base_use_limit', TType.I32, 5)
      oprot.writeI32(self.base_use_limit)
      oprot.writeFieldEnd()
    if self.dynamic_baf is not None:
      oprot.writeFieldBegin('dynamic_baf', TType.I32, 6)
      oprot.writeI32(self.dynamic_baf)
      oprot.writeFieldEnd()
    if self.hysteresis is not None:
      oprot.writeFieldBegin('hysteresis', TType.I32, 7)
      oprot.writeI32(self.hysteresis)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.base_use_limit)
    value = (value * 31) ^ hash(self.dynamic_baf)
    value = (value * 31) ^ hash(self.hysteresis)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_app_pool_usage_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_app_pool_usage_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_app_pool_usage_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_app_pool_usage_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_app_pool_usage_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_app_pool_usage_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_guaranteed_min_limit_args:
  """
  Attributes:
   - dev
   - port
   - q
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.I32, 'cells', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, q=None, cells=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_guaranteed_min_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 4)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_guaranteed_min_limit_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_guaranteed_min_limit_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_color_limit_args:
  """
  Attributes:
   - dev
   - port
   - q
   - color
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.I32, 'color', None, None, ), # 4
    (5, TType.I32, 'cells', None, None, ), # 5
  )

  def __init__(self, dev=None, port=None, q=None, color=None, cells=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.color = color
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.color = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_color_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.color is not None:
      oprot.writeFieldBegin('color', TType.I32, 4)
      oprot.writeI32(self.color)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 5)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.color)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_color_limit_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_color_limit_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_color_hysteresis_args:
  """
  Attributes:
   - dev
   - port
   - q
   - color
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.I32, 'color', None, None, ), # 4
    (5, TType.I32, 'cells', None, None, ), # 5
  )

  def __init__(self, dev=None, port=None, q=None, color=None, cells=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.color = color
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.color = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_color_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.color is not None:
      oprot.writeFieldBegin('color', TType.I32, 4)
      oprot.writeI32(self.color)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 5)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.color)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_color_hysteresis_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_color_hysteresis_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_q_tail_drop_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_q_tail_drop_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_q_tail_drop_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_q_tail_drop_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_tail_drop_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_tail_drop_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_tail_drop_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_tail_drop_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_q_color_drop_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_q_color_drop_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_q_color_drop_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_q_color_drop_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_color_drop_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_color_drop_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_color_drop_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_color_drop_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_negative_mirror_dest_args:
  """
  Attributes:
   - dev
   - pipe
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
    (3, TType.I32, 'port', None, None, ), # 3
    (4, TType.I32, 'q', None, None, ), # 4
  )

  def __init__(self, dev=None, pipe=None, port=None, q=None,):
    self.dev = dev
    self.pipe = pipe
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_negative_mirror_dest_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 3)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 4)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_negative_mirror_dest_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_negative_mirror_dest_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_pfc_cos_mapping_args:
  """
  Attributes:
   - dev
   - port
   - q
   - cos
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.I16, 'cos', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, q=None, cos=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.cos = cos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.cos = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_pfc_cos_mapping_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.cos is not None:
      oprot.writeFieldBegin('cos', TType.I16, 4)
      oprot.writeI16(self.cos)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.cos)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_pfc_cos_mapping_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_pfc_cos_mapping_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_app_pool_size_args:
  """
  Attributes:
   - dev
   - pool
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
    (3, TType.I32, 'cells', None, None, ), # 3
  )

  def __init__(self, dev=None, pool=None, cells=None,):
    self.dev = dev
    self.pool = pool
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_app_pool_size_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 3)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_app_pool_size_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_app_pool_size_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_app_pool_color_drop_args:
  """
  Attributes:
   - dev
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
  )

  def __init__(self, dev=None, pool=None,):
    self.dev = dev
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_app_pool_color_drop_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_app_pool_color_drop_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_app_pool_color_drop_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_app_pool_color_drop_args:
  """
  Attributes:
   - dev
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
  )

  def __init__(self, dev=None, pool=None,):
    self.dev = dev
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_app_pool_color_drop_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_app_pool_color_drop_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_app_pool_color_drop_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_app_pool_color_drop_limit_args:
  """
  Attributes:
   - dev
   - pool
   - color
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
    (3, TType.I32, 'color', None, None, ), # 3
    (4, TType.I32, 'cells', None, None, ), # 4
  )

  def __init__(self, dev=None, pool=None, color=None, cells=None,):
    self.dev = dev
    self.pool = pool
    self.color = color
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.color = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_app_pool_color_drop_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    if self.color is not None:
      oprot.writeFieldBegin('color', TType.I32, 3)
      oprot.writeI32(self.color)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 4)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.color)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_app_pool_color_drop_limit_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_app_pool_color_drop_limit_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_app_pool_color_drop_hysteresis_args:
  """
  Attributes:
   - dev
   - color
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'color', None, None, ), # 2
    (3, TType.I32, 'cells', None, None, ), # 3
  )

  def __init__(self, dev=None, color=None, cells=None,):
    self.dev = dev
    self.color = color
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.color = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_app_pool_color_drop_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.color is not None:
      oprot.writeFieldBegin('color', TType.I32, 2)
      oprot.writeI32(self.color)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 3)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.color)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_app_pool_color_drop_hysteresis_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_app_pool_color_drop_hysteresis_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_app_pool_pfc_limit_args:
  """
  Attributes:
   - dev
   - pool
   - icos
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
    (3, TType.I16, 'icos', None, None, ), # 3
    (4, TType.I32, 'cells', None, None, ), # 4
  )

  def __init__(self, dev=None, pool=None, icos=None, cells=None,):
    self.dev = dev
    self.pool = pool
    self.icos = icos
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.icos = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_app_pool_pfc_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    if self.icos is not None:
      oprot.writeFieldBegin('icos', TType.I16, 3)
      oprot.writeI16(self.icos)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 4)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.icos)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_app_pool_pfc_limit_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_app_pool_pfc_limit_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_skid_pool_size_args:
  """
  Attributes:
   - dev
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'cells', None, None, ), # 2
  )

  def __init__(self, dev=None, cells=None,):
    self.dev = dev
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_skid_pool_size_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 2)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_skid_pool_size_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_skid_pool_size_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_skid_pool_hysteresis_args:
  """
  Attributes:
   - dev
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'cells', None, None, ), # 2
  )

  def __init__(self, dev=None, cells=None,):
    self.dev = dev
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_skid_pool_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 2)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_skid_pool_hysteresis_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_skid_pool_hysteresis_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_negative_mirror_pool_size_args:
  """
  Attributes:
   - dev
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'cells', None, None, ), # 2
  )

  def __init__(self, dev=None, cells=None,):
    self.dev = dev
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_negative_mirror_pool_size_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 2)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_negative_mirror_pool_size_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_negative_mirror_pool_size_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_uc_cut_through_pool_size_args:
  """
  Attributes:
   - dev
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'cells', None, None, ), # 2
  )

  def __init__(self, dev=None, cells=None,):
    self.dev = dev
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_uc_cut_through_pool_size_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 2)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_uc_cut_through_pool_size_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_uc_cut_through_pool_size_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_mc_cut_through_pool_size_args:
  """
  Attributes:
   - dev
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'cells', None, None, ), # 2
  )

  def __init__(self, dev=None, cells=None,):
    self.dev = dev
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_mc_cut_through_pool_size_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 2)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_mc_cut_through_pool_size_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_mc_cut_through_pool_size_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_egress_pipe_limit_args:
  """
  Attributes:
   - dev
   - pipe
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
    (3, TType.I32, 'cells', None, None, ), # 3
  )

  def __init__(self, dev=None, pipe=None, cells=None,):
    self.dev = dev
    self.pipe = pipe
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_egress_pipe_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 3)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_egress_pipe_limit_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_egress_pipe_limit_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_egress_pipe_hysteresis_args:
  """
  Attributes:
   - dev
   - pipe
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
    (3, TType.I32, 'cells', None, None, ), # 3
  )

  def __init__(self, dev=None, pipe=None, cells=None,):
    self.dev = dev
    self.pipe = pipe
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_egress_pipe_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 3)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_egress_pipe_hysteresis_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_egress_pipe_hysteresis_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ingress_port_drop_limit_args:
  """
  Attributes:
   - dev
   - port
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'cells', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, cells=None,):
    self.dev = dev
    self.port = port
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ingress_port_drop_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 3)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ingress_port_drop_limit_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ingress_port_drop_limit_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ingress_port_hysteresis_args:
  """
  Attributes:
   - dev
   - port
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'cells', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, cells=None,):
    self.dev = dev
    self.port = port
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ingress_port_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 3)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ingress_port_hysteresis_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ingress_port_hysteresis_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_port_uc_cut_through_limit_args:
  """
  Attributes:
   - dev
   - port
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'cells', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, cells=None,):
    self.dev = dev
    self.port = port
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cells = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_port_uc_cut_through_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.I32, 3)
      oprot.writeI32(self.cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.cells)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_port_uc_cut_through_limit_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_port_uc_cut_through_limit_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_port_flowcontrol_mode_args:
  """
  Attributes:
   - dev
   - port
   - fctype
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'fctype', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, fctype=None,):
    self.dev = dev
    self.port = port
    self.fctype = fctype

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.fctype = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_port_flowcontrol_mode_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.fctype is not None:
      oprot.writeFieldBegin('fctype', TType.I32, 3)
      oprot.writeI32(self.fctype)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.fctype)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_port_flowcontrol_mode_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_port_flowcontrol_mode_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_port_pfc_cos_mapping_args:
  """
  Attributes:
   - dev
   - port
   - cos_icos_map
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.STRUCT, 'cos_icos_map', (tm_pfc_cos_map_t, tm_pfc_cos_map_t.thrift_spec), None, ), # 3
  )

  def __init__(self, dev=None, port=None, cos_icos_map=None,):
    self.dev = dev
    self.port = port
    self.cos_icos_map = cos_icos_map

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.cos_icos_map = tm_pfc_cos_map_t()
          self.cos_icos_map.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_port_pfc_cos_mapping_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.cos_icos_map is not None:
      oprot.writeFieldBegin('cos_icos_map', TType.STRUCT, 3)
      self.cos_icos_map.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.cos_icos_map)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_port_pfc_cos_mapping_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_port_pfc_cos_mapping_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_cpuport_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_cpuport_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_cpuport_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_cpuport_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_reset_cpuport_args:
  """
  Attributes:
   - dev
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
  )

  def __init__(self, dev=None,):
    self.dev = dev

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_reset_cpuport_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_reset_cpuport_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_reset_cpuport_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_sched_priority_args:
  """
  Attributes:
   - dev
   - port
   - q
   - prio
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.I32, 'prio', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, q=None, prio=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.prio = prio

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.prio = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_sched_priority_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.prio is not None:
      oprot.writeFieldBegin('prio', TType.I32, 4)
      oprot.writeI32(self.prio)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.prio)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_sched_priority_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_sched_priority_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_dwrr_weight_args:
  """
  Attributes:
   - dev
   - port
   - q
   - weight
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.I16, 'weight', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, q=None, weight=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.weight = weight

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.weight = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_dwrr_weight_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.weight is not None:
      oprot.writeFieldBegin('weight', TType.I16, 4)
      oprot.writeI16(self.weight)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.weight)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_dwrr_weight_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_dwrr_weight_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_shaping_rate_args:
  """
  Attributes:
   - dev
   - port
   - q
   - pps
   - burstsize
   - rate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.BOOL, 'pps', None, None, ), # 4
    (5, TType.I32, 'burstsize', None, None, ), # 5
    (6, TType.I32, 'rate', None, None, ), # 6
  )

  def __init__(self, dev=None, port=None, q=None, pps=None, burstsize=None, rate=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.pps = pps
    self.burstsize = burstsize
    self.rate = rate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.pps = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.burstsize = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.rate = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_shaping_rate_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.pps is not None:
      oprot.writeFieldBegin('pps', TType.BOOL, 4)
      oprot.writeBool(self.pps)
      oprot.writeFieldEnd()
    if self.burstsize is not None:
      oprot.writeFieldBegin('burstsize', TType.I32, 5)
      oprot.writeI32(self.burstsize)
      oprot.writeFieldEnd()
    if self.rate is not None:
      oprot.writeFieldBegin('rate', TType.I32, 6)
      oprot.writeI32(self.rate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.pps)
    value = (value * 31) ^ hash(self.burstsize)
    value = (value * 31) ^ hash(self.rate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_shaping_rate_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_shaping_rate_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_guaranteed_rate_args:
  """
  Attributes:
   - dev
   - port
   - q
   - pps
   - burstsize
   - rate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.BOOL, 'pps', None, None, ), # 4
    (5, TType.I32, 'burstsize', None, None, ), # 5
    (6, TType.I32, 'rate', None, None, ), # 6
  )

  def __init__(self, dev=None, port=None, q=None, pps=None, burstsize=None, rate=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.pps = pps
    self.burstsize = burstsize
    self.rate = rate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.pps = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.burstsize = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.rate = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_guaranteed_rate_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.pps is not None:
      oprot.writeFieldBegin('pps', TType.BOOL, 4)
      oprot.writeBool(self.pps)
      oprot.writeFieldEnd()
    if self.burstsize is not None:
      oprot.writeFieldBegin('burstsize', TType.I32, 5)
      oprot.writeI32(self.burstsize)
      oprot.writeFieldEnd()
    if self.rate is not None:
      oprot.writeFieldBegin('rate', TType.I32, 6)
      oprot.writeI32(self.rate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.pps)
    value = (value * 31) ^ hash(self.burstsize)
    value = (value * 31) ^ hash(self.rate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_guaranteed_rate_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_guaranteed_rate_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_remaining_bw_sched_priority_args:
  """
  Attributes:
   - dev
   - port
   - q
   - prio
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.I32, 'prio', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, q=None, prio=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.prio = prio

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.prio = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_remaining_bw_sched_priority_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.prio is not None:
      oprot.writeFieldBegin('prio', TType.I32, 4)
      oprot.writeI32(self.prio)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.prio)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_q_remaining_bw_sched_priority_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_q_remaining_bw_sched_priority_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_q_l1_set_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
    (4, TType.I32, 'q', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, l1_node=None, q=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_q_l1_set_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 4)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_q_l1_set_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_q_l1_set_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_q_l1_reset_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_q_l1_reset_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_q_l1_reset_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_q_l1_reset_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_priority_set_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
    (4, TType.I32, 'priority', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, l1_node=None, priority=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_priority_set_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 4)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_priority_set_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_priority_set_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_dwrr_weight_set_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
   - weight
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
    (4, TType.I16, 'weight', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, l1_node=None, weight=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node
    self.weight = weight

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.weight = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_dwrr_weight_set_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    if self.weight is not None:
      oprot.writeFieldBegin('weight', TType.I16, 4)
      oprot.writeI16(self.weight)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    value = (value * 31) ^ hash(self.weight)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_dwrr_weight_set_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_dwrr_weight_set_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_shaping_rate_set_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
   - pps
   - burst_size
   - rate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
    (4, TType.BOOL, 'pps', None, None, ), # 4
    (5, TType.I32, 'burst_size', None, None, ), # 5
    (6, TType.I32, 'rate', None, None, ), # 6
  )

  def __init__(self, dev=None, port=None, l1_node=None, pps=None, burst_size=None, rate=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node
    self.pps = pps
    self.burst_size = burst_size
    self.rate = rate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.pps = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.burst_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.rate = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_shaping_rate_set_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    if self.pps is not None:
      oprot.writeFieldBegin('pps', TType.BOOL, 4)
      oprot.writeBool(self.pps)
      oprot.writeFieldEnd()
    if self.burst_size is not None:
      oprot.writeFieldBegin('burst_size', TType.I32, 5)
      oprot.writeI32(self.burst_size)
      oprot.writeFieldEnd()
    if self.rate is not None:
      oprot.writeFieldBegin('rate', TType.I32, 6)
      oprot.writeI32(self.rate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    value = (value * 31) ^ hash(self.pps)
    value = (value * 31) ^ hash(self.burst_size)
    value = (value * 31) ^ hash(self.rate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_shaping_rate_set_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_shaping_rate_set_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_max_shaping_rate_enable_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, l1_node=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_max_shaping_rate_enable_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_max_shaping_rate_enable_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_max_shaping_rate_enable_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_max_shaping_rate_disable_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, l1_node=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_max_shaping_rate_disable_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_max_shaping_rate_disable_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_max_shaping_rate_disable_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_priority_prop_enable_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, l1_node=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_priority_prop_enable_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_priority_prop_enable_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_priority_prop_enable_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_priority_prop_disable_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, l1_node=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_priority_prop_disable_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_priority_prop_disable_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_priority_prop_disable_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_guaranteed_rate_set_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
   - pps
   - burst_size
   - rate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
    (4, TType.BOOL, 'pps', None, None, ), # 4
    (5, TType.I32, 'burst_size', None, None, ), # 5
    (6, TType.I32, 'rate', None, None, ), # 6
  )

  def __init__(self, dev=None, port=None, l1_node=None, pps=None, burst_size=None, rate=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node
    self.pps = pps
    self.burst_size = burst_size
    self.rate = rate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.pps = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.burst_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.rate = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_guaranteed_rate_set_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    if self.pps is not None:
      oprot.writeFieldBegin('pps', TType.BOOL, 4)
      oprot.writeBool(self.pps)
      oprot.writeFieldEnd()
    if self.burst_size is not None:
      oprot.writeFieldBegin('burst_size', TType.I32, 5)
      oprot.writeI32(self.burst_size)
      oprot.writeFieldEnd()
    if self.rate is not None:
      oprot.writeFieldBegin('rate', TType.I32, 6)
      oprot.writeI32(self.rate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    value = (value * 31) ^ hash(self.pps)
    value = (value * 31) ^ hash(self.burst_size)
    value = (value * 31) ^ hash(self.rate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_guaranteed_rate_set_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_guaranteed_rate_set_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_remaining_bw_priority_set_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
    (4, TType.I32, 'priority', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, l1_node=None, priority=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_remaining_bw_priority_set_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 4)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_remaining_bw_priority_set_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_remaining_bw_priority_set_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_guaranteed_rate_enable_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, l1_node=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_guaranteed_rate_enable_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_guaranteed_rate_enable_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_guaranteed_rate_enable_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_guaranteed_rate_disable_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, l1_node=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_guaranteed_rate_disable_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_guaranteed_rate_disable_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_guaranteed_rate_disable_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_enable_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, l1_node=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_enable_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_enable_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_enable_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_disable_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, l1_node=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_disable_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_disable_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_disable_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_free_args:
  """
  Attributes:
   - dev
   - port
   - l1_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'l1_node', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, l1_node=None,):
    self.dev = dev
    self.port = port
    self.l1_node = l1_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.l1_node = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_free_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.l1_node is not None:
      oprot.writeFieldBegin('l1_node', TType.I32, 3)
      oprot.writeI32(self.l1_node)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.l1_node)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_sched_l1_free_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_sched_l1_free_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_port_shaping_rate_args:
  """
  Attributes:
   - dev
   - port
   - pps
   - burstsize
   - rate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.BOOL, 'pps', None, None, ), # 3
    (4, TType.I32, 'burstsize', None, None, ), # 4
    (5, TType.I32, 'rate', None, None, ), # 5
  )

  def __init__(self, dev=None, port=None, pps=None, burstsize=None, rate=None,):
    self.dev = dev
    self.port = port
    self.pps = pps
    self.burstsize = burstsize
    self.rate = rate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.pps = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.burstsize = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.rate = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_port_shaping_rate_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.pps is not None:
      oprot.writeFieldBegin('pps', TType.BOOL, 3)
      oprot.writeBool(self.pps)
      oprot.writeFieldEnd()
    if self.burstsize is not None:
      oprot.writeFieldBegin('burstsize', TType.I32, 4)
      oprot.writeI32(self.burstsize)
      oprot.writeFieldEnd()
    if self.rate is not None:
      oprot.writeFieldBegin('rate', TType.I32, 5)
      oprot.writeI32(self.rate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.pps)
    value = (value * 31) ^ hash(self.burstsize)
    value = (value * 31) ^ hash(self.rate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_port_shaping_rate_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_port_shaping_rate_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_shaper_pkt_ifg_compensation_args:
  """
  Attributes:
   - dev
   - pipe
   - adjustment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
    (3, TType.I16, 'adjustment', None, None, ), # 3
  )

  def __init__(self, dev=None, pipe=None, adjustment=None,):
    self.dev = dev
    self.pipe = pipe
    self.adjustment = adjustment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.adjustment = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_shaper_pkt_ifg_compensation_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    if self.adjustment is not None:
      oprot.writeFieldBegin('adjustment', TType.I16, 3)
      oprot.writeI16(self.adjustment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    value = (value * 31) ^ hash(self.adjustment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_shaper_pkt_ifg_compensation_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_shaper_pkt_ifg_compensation_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_q_sched_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_q_sched_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_q_sched_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_q_sched_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_sched_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_sched_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_sched_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_sched_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_port_shaping_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_port_shaping_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_port_shaping_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_port_shaping_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_port_shaping_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_port_shaping_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_port_shaping_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_port_shaping_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_port_sched_args:
  """
  Attributes:
   - dev
   - port
   - speed
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'speed', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, speed=None,):
    self.dev = dev
    self.port = port
    self.speed = speed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.speed = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_port_sched_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.speed is not None:
      oprot.writeFieldBegin('speed', TType.I32, 3)
      oprot.writeI32(self.speed)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.speed)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_port_sched_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_port_sched_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_port_sched_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_port_sched_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_port_sched_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_port_sched_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_q_max_shaping_rate_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_q_max_shaping_rate_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_q_max_shaping_rate_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_q_max_shaping_rate_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_max_shaping_rate_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_max_shaping_rate_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_max_shaping_rate_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_max_shaping_rate_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_q_min_shaping_rate_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_q_min_shaping_rate_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_enable_q_min_shaping_rate_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_enable_q_min_shaping_rate_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_min_shaping_rate_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_min_shaping_rate_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_disable_q_min_shaping_rate_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_disable_q_min_shaping_rate_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_complete_operations_args:
  """
  Attributes:
   - dev
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
  )

  def __init__(self, dev=None,):
    self.dev = dev

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_complete_operations_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_complete_operations_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_complete_operations_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_timestamp_shift_args:
  """
  Attributes:
   - dev
   - shift
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I16, 'shift', None, None, ), # 2
  )

  def __init__(self, dev=None, shift=None,):
    self.dev = dev
    self.shift = shift

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.shift = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_timestamp_shift_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.shift is not None:
      oprot.writeFieldBegin('shift', TType.I16, 2)
      oprot.writeI16(self.shift)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.shift)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_timestamp_shift_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_timestamp_shift_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_sched_priority_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_sched_priority_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_sched_priority_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_sched_priority_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_dwrr_weight_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_dwrr_weight_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_dwrr_weight_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_dwrr_weight_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_shaping_rate_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_shaping_rate_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_shaping_rate_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (tm_shaper_rate_t, tm_shaper_rate_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = tm_shaper_rate_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_shaping_rate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_guaranteed_rate_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_guaranteed_rate_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_guaranteed_rate_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (tm_shaper_rate_t, tm_shaper_rate_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = tm_shaper_rate_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_guaranteed_rate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_remaining_bw_sched_priority_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_remaining_bw_sched_priority_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_remaining_bw_sched_priority_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_remaining_bw_sched_priority_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_port_shaping_rate_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_port_shaping_rate_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_port_shaping_rate_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (tm_shaper_rate_t, tm_shaper_rate_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = tm_shaper_rate_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_port_shaping_rate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_shaper_pkt_ifg_compensation_args:
  """
  Attributes:
   - dev
   - pipe
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
  )

  def __init__(self, dev=None, pipe=None,):
    self.dev = dev
    self.pipe = pipe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_shaper_pkt_ifg_compensation_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_shaper_pkt_ifg_compensation_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_shaper_pkt_ifg_compensation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_egress_pipe_limit_args:
  """
  Attributes:
   - dev
   - pipe
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
  )

  def __init__(self, dev=None, pipe=None,):
    self.dev = dev
    self.pipe = pipe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_egress_pipe_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_egress_pipe_limit_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_egress_pipe_limit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_egress_pipe_hysteresis_args:
  """
  Attributes:
   - dev
   - pipe
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
  )

  def __init__(self, dev=None, pipe=None,):
    self.dev = dev
    self.pipe = pipe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_egress_pipe_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_egress_pipe_hysteresis_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_egress_pipe_hysteresis_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_port_q_mapping_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_port_q_mapping_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_port_q_mapping_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (tm_q_map_t, tm_q_map_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = tm_q_map_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_port_q_mapping_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_app_pool_usage_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_app_pool_usage_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_app_pool_usage_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (tm_pool_usage_t, tm_pool_usage_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = tm_pool_usage_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_app_pool_usage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_guaranteed_min_limit_args:
  """
  Attributes:
   - dev
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
  )

  def __init__(self, dev=None, port=None, q=None,):
    self.dev = dev
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_guaranteed_min_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_guaranteed_min_limit_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_guaranteed_min_limit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_color_limit_args:
  """
  Attributes:
   - dev
   - port
   - q
   - color
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.I32, 'color', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, q=None, color=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.color = color

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.color = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_color_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.color is not None:
      oprot.writeFieldBegin('color', TType.I32, 4)
      oprot.writeI32(self.color)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.color)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_color_limit_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_color_limit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_color_hysteresis_args:
  """
  Attributes:
   - dev
   - port
   - q
   - color
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I32, 'q', None, None, ), # 3
    (4, TType.I32, 'color', None, None, ), # 4
  )

  def __init__(self, dev=None, port=None, q=None, color=None,):
    self.dev = dev
    self.port = port
    self.q = q
    self.color = color

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.color = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_color_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 3)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    if self.color is not None:
      oprot.writeFieldBegin('color', TType.I32, 4)
      oprot.writeI32(self.color)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    value = (value * 31) ^ hash(self.color)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_color_hysteresis_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_color_hysteresis_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_port_uc_cut_through_limit_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_port_uc_cut_through_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_port_uc_cut_through_limit_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_port_uc_cut_through_limit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_total_ppg_args:
  """
  Attributes:
   - dev
   - pipe
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
  )

  def __init__(self, dev=None, pipe=None,):
    self.dev = dev
    self.pipe = pipe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_total_ppg_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_total_ppg_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_total_ppg_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_unused_ppg_count_args:
  """
  Attributes:
   - dev
   - pipe
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
  )

  def __init__(self, dev=None, pipe=None,):
    self.dev = dev
    self.pipe = pipe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_unused_ppg_count_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_unused_ppg_count_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_unused_ppg_count_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_app_pool_usage_args:
  """
  Attributes:
   - dev
   - ppg
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
    (3, TType.I32, 'pool', None, None, ), # 3
  )

  def __init__(self, dev=None, ppg=None, pool=None,):
    self.dev = dev
    self.ppg = ppg
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_app_pool_usage_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 3)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    value = (value * 31) ^ hash(self.pool)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_app_pool_usage_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (tm_pool_usage_t, tm_pool_usage_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = tm_pool_usage_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_app_pool_usage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_guaranteed_min_limit_args:
  """
  Attributes:
   - dev
   - ppg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
  )

  def __init__(self, dev=None, ppg=None,):
    self.dev = dev
    self.ppg = ppg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_guaranteed_min_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_guaranteed_min_limit_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_guaranteed_min_limit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_skid_limit_args:
  """
  Attributes:
   - dev
   - ppg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
  )

  def __init__(self, dev=None, ppg=None,):
    self.dev = dev
    self.ppg = ppg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_skid_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_skid_limit_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_skid_limit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_guaranteed_min_skid_hysteresis_args:
  """
  Attributes:
   - dev
   - ppg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
  )

  def __init__(self, dev=None, ppg=None,):
    self.dev = dev
    self.ppg = ppg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_guaranteed_min_skid_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_guaranteed_min_skid_hysteresis_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_guaranteed_min_skid_hysteresis_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_app_pool_size_args:
  """
  Attributes:
   - dev
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
  )

  def __init__(self, dev=None, pool=None,):
    self.dev = dev
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_app_pool_size_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_app_pool_size_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_app_pool_size_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_app_pool_color_drop_limit_args:
  """
  Attributes:
   - dev
   - pool
   - color
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
    (3, TType.I32, 'color', None, None, ), # 3
  )

  def __init__(self, dev=None, pool=None, color=None,):
    self.dev = dev
    self.pool = pool
    self.color = color

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.color = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_app_pool_color_drop_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    if self.color is not None:
      oprot.writeFieldBegin('color', TType.I32, 3)
      oprot.writeI32(self.color)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.color)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_app_pool_color_drop_limit_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_app_pool_color_drop_limit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_app_pool_color_drop_hysteresis_args:
  """
  Attributes:
   - dev
   - color
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'color', None, None, ), # 2
  )

  def __init__(self, dev=None, color=None,):
    self.dev = dev
    self.color = color

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.color = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_app_pool_color_drop_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.color is not None:
      oprot.writeFieldBegin('color', TType.I32, 2)
      oprot.writeI32(self.color)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.color)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_app_pool_color_drop_hysteresis_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_app_pool_color_drop_hysteresis_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_app_pool_pfc_limit_args:
  """
  Attributes:
   - dev
   - pool
   - icos
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
    (3, TType.I16, 'icos', None, None, ), # 3
  )

  def __init__(self, dev=None, pool=None, icos=None,):
    self.dev = dev
    self.pool = pool
    self.icos = icos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.icos = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_app_pool_pfc_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    if self.icos is not None:
      oprot.writeFieldBegin('icos', TType.I16, 3)
      oprot.writeI16(self.icos)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    value = (value * 31) ^ hash(self.icos)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_app_pool_pfc_limit_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_app_pool_pfc_limit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_skid_pool_size_args:
  """
  Attributes:
   - dev
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
  )

  def __init__(self, dev=None,):
    self.dev = dev

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_skid_pool_size_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_skid_pool_size_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_skid_pool_size_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_skid_pool_hysteresis_args:
  """
  Attributes:
   - dev
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
  )

  def __init__(self, dev=None,):
    self.dev = dev

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_skid_pool_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_skid_pool_hysteresis_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_skid_pool_hysteresis_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_negative_mirror_pool_size_args:
  """
  Attributes:
   - dev
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
  )

  def __init__(self, dev=None,):
    self.dev = dev

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_negative_mirror_pool_size_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_negative_mirror_pool_size_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_negative_mirror_pool_size_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_uc_cut_through_pool_size_args:
  """
  Attributes:
   - dev
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
  )

  def __init__(self, dev=None, pool=None,):
    self.dev = dev
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_uc_cut_through_pool_size_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_uc_cut_through_pool_size_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_uc_cut_through_pool_size_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_mc_cut_through_pool_size_args:
  """
  Attributes:
   - dev
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
  )

  def __init__(self, dev=None, pool=None,):
    self.dev = dev
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_mc_cut_through_pool_size_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_mc_cut_through_pool_size_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_mc_cut_through_pool_size_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ingress_port_drop_limit_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ingress_port_drop_limit_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ingress_port_drop_limit_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ingress_port_drop_limit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ingress_port_hysteresis_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ingress_port_hysteresis_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ingress_port_hysteresis_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ingress_port_hysteresis_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_port_flowcontrol_mode_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_port_flowcontrol_mode_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_port_flowcontrol_mode_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_port_flowcontrol_mode_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_port_pfc_cos_mapping_args:
  """
  Attributes:
   - dev
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, dev=None, port=None,):
    self.dev = dev
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_port_pfc_cos_mapping_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_port_pfc_cos_mapping_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (tm_pfc_cos_map_t, tm_pfc_cos_map_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = tm_pfc_cos_map_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_port_pfc_cos_mapping_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_icos_mapping_args:
  """
  Attributes:
   - dev
   - ppg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'ppg', None, None, ), # 2
  )

  def __init__(self, dev=None, ppg=None,):
    self.dev = dev
    self.ppg = ppg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_icos_mapping_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 2)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.ppg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_icos_mapping_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_icos_mapping_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_timestamp_shift_args:
  """
  Attributes:
   - dev
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
  )

  def __init__(self, dev=None,):
    self.dev = dev

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_timestamp_shift_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_timestamp_shift_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_timestamp_shift_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_drop_args:
  """
  Attributes:
   - dev
   - pipe
   - ppg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
    (3, TType.I32, 'ppg', None, None, ), # 3
  )

  def __init__(self, dev=None, pipe=None, ppg=None,):
    self.dev = dev
    self.pipe = pipe
    self.ppg = ppg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_drop_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 3)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    value = (value * 31) ^ hash(self.ppg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_drop_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_drop_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_drop_args:
  """
  Attributes:
   - dev
   - pipe
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
    (3, TType.I32, 'port', None, None, ), # 3
    (4, TType.I32, 'q', None, None, ), # 4
  )

  def __init__(self, dev=None, pipe=None, port=None, q=None,):
    self.dev = dev
    self.pipe = pipe
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_drop_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 3)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 4)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_drop_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_drop_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_usage_args:
  """
  Attributes:
   - dev
   - pipe
   - ppg
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
    (3, TType.I32, 'ppg', None, None, ), # 3
  )

  def __init__(self, dev=None, pipe=None, ppg=None,):
    self.dev = dev
    self.pipe = pipe
    self.ppg = ppg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.ppg = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_usage_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    if self.ppg is not None:
      oprot.writeFieldBegin('ppg', TType.I32, 3)
      oprot.writeI32(self.ppg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    value = (value * 31) ^ hash(self.ppg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_ppg_usage_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (tm_ppg_usage_t, tm_ppg_usage_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = tm_ppg_usage_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_ppg_usage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_usage_args:
  """
  Attributes:
   - dev
   - pipe
   - port
   - q
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pipe', None, None, ), # 2
    (3, TType.I32, 'port', None, None, ), # 3
    (4, TType.I32, 'q', None, None, ), # 4
  )

  def __init__(self, dev=None, pipe=None, port=None, q=None,):
    self.dev = dev
    self.pipe = pipe
    self.port = port
    self.q = q

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pipe = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.q = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_usage_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pipe is not None:
      oprot.writeFieldBegin('pipe', TType.I32, 2)
      oprot.writeI32(self.pipe)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 3)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.q is not None:
      oprot.writeFieldBegin('q', TType.I32, 4)
      oprot.writeI32(self.q)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pipe)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.q)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_q_usage_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (tm_usage_t, tm_usage_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = tm_usage_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_q_usage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_pool_usage_args:
  """
  Attributes:
   - dev
   - pool
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
    (2, TType.I32, 'pool', None, None, ), # 2
  )

  def __init__(self, dev=None, pool=None,):
    self.dev = dev
    self.pool = pool

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.pool = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_pool_usage_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    if self.pool is not None:
      oprot.writeFieldBegin('pool', TType.I32, 2)
      oprot.writeI32(self.pool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    value = (value * 31) ^ hash(self.pool)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_get_pool_usage_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (tm_usage_t, tm_usage_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = tm_usage_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_get_pool_usage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ut_mode_as_model_args:
  """
  Attributes:
   - dev
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
  )

  def __init__(self, dev=None,):
    self.dev = dev

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ut_mode_as_model_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ut_mode_as_model_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ut_mode_as_model_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ut_mode_as_asic_args:
  """
  Attributes:
   - dev
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev', None, None, ), # 1
  )

  def __init__(self, dev=None,):
    self.dev = dev

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ut_mode_as_asic_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.I32, 1)
      oprot.writeI32(self.dev)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tm_set_ut_mode_as_asic_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (InvalidTmOperation, InvalidTmOperation.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = InvalidTmOperation()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tm_set_ut_mode_as_asic_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ouch)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
